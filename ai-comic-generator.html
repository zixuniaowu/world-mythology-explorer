<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIç¥è©±æ¼«ç•«ç”Ÿæˆç³»çµ± - åœ–åƒæ•…äº‹å‰µä½œå¹³å°</title>
    
    <!-- å¤–éƒ¨åº« -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 25px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-container {
            flex: 1;
            display: flex;
            max-width: 1600px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
            gap: 20px;
        }

        .input-panel {
            width: 400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .panel-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #ffd700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .story-textarea {
            width: 100%;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            padding: 15px;
            font-size: 1em;
            line-height: 1.6;
            resize: vertical;
            font-family: inherit;
        }

        .story-textarea::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .example-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .example-btn {
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .example-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: #ffd700;
        }

        .config-group {
            margin-bottom: 15px;
        }

        .config-label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.95em;
            color: #ccc;
        }

        .config-select, .config-input {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-family: inherit;
        }

        .config-select option {
            background: #333;
            color: white;
        }

        .generate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #ffd700 0%, #ffb347 100%);
            border: none;
            border-radius: 10px;
            color: #333;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }

        .generate-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
        }

        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .comic-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            overflow-y: auto;
        }

        .comic-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .comic-title {
            font-size: 1.8em;
            color: #ffd700;
        }

        .view-controls {
            display: flex;
            gap: 10px;
        }

        .view-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .view-btn.active {
            background: #ffd700;
            color: #333;
            border-color: #ffd700;
        }

        .comic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            padding: 20px;
            background: white;
            border-radius: 10px;
        }

        .comic-panel {
            background: white;
            border: 3px solid #333;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .panel-number {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #ffd700;
            color: #333;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 0.9em;
            z-index: 10;
        }

        .panel-image {
            width: 100%;
            height: 250px;
            background: linear-gradient(135deg, #e0e0e0, #f5f5f5);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .panel-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .panel-placeholder {
            text-align: center;
            color: #999;
            padding: 20px;
        }

        .panel-text {
            padding: 15px;
            background: white;
            color: #333;
            font-size: 0.95em;
            line-height: 1.5;
            border-top: 2px solid #f0f0f0;
        }

        .speech-bubble {
            background: white;
            border: 2px solid #333;
            border-radius: 15px;
            padding: 10px;
            margin: 10px;
            position: relative;
            color: #333;
            font-weight: bold;
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 30px;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid #333;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            text-align: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 215, 0, 0.3);
            border-top-color: #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.2em;
            color: #ffd700;
            margin-bottom: 10px;
        }

        .loading-progress {
            font-size: 0.9em;
            color: #ccc;
        }

        .storyboard-view {
            display: none;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .storyboard-item {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            align-items: center;
        }

        .storyboard-number {
            font-size: 2em;
            color: #ffd700;
            font-weight: bold;
            min-width: 50px;
        }

        .storyboard-content {
            flex: 1;
        }

        .storyboard-prompt {
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.9em;
            color: #4ecdc4;
        }

        .storyboard-description {
            line-height: 1.6;
        }

        .manga-layout {
            display: none;
            background: white;
            padding: 30px;
            border-radius: 10px;
        }

        .manga-page {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .manga-row {
            display: flex;
            min-height: 300px;
        }

        .manga-cell {
            flex: 1;
            border: 2px solid #333;
            position: relative;
            overflow: hidden;
        }

        .manga-cell.large {
            flex: 2;
        }

        .export-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .export-btn {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
            }
            
            .input-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ¨ AIç¥è©±æ¼«ç•«ç”Ÿæˆç³»çµ±</h1>
        <p class="subtitle">å°‡ç¥è©±æ•…äº‹è½‰åŒ–ç‚ºç²¾ç¾çš„AIæ¼«ç•«ä½œå“</p>
    </div>

    <div class="main-container">
        <div class="input-panel">
            <!-- æ•…äº‹è¼¸å…¥ -->
            <div class="panel">
                <h3 class="panel-title">
                    <span>ğŸ“–</span>
                    <span>è¼¸å…¥ç¥è©±æ•…äº‹</span>
                </h3>
                
                <textarea class="story-textarea" id="storyInput" placeholder="è¼¸å…¥æ‚¨çš„ç¥è©±æ•…äº‹...

ä¾‹å¦‚ï¼š
å¤¸çˆ¶æ˜¯ä¸€ä½å·¨äººï¼Œä»–çœ‹åˆ°å¤ªé™½æ¯å¤©å¾æ±æ–¹å‡èµ·è¥¿æ–¹è½ä¸‹ï¼Œæ±ºå¿ƒè¦è¿½ä¸Šå¤ªé™½ã€‚ä»–é‚é–‹å·¨å¤§çš„æ­¥ä¼ï¼Œç¿»è¶Šé«˜å±±ï¼Œè·¨éæ²³æµã€‚æ¸´äº†å°±å–ä¹¾é»ƒæ²³ã€æ¸­æ°´ã€‚æœ€çµ‚åŠ›ç«­è€Œäº¡ï¼Œä»–çš„æ‰‹æ–åŒ–ä½œæ¡ƒæ—ã€‚"></textarea>

                <div class="example-buttons">
                    <button class="example-btn" onclick="loadExample('kuafu')">å¤¸çˆ¶é€æ—¥</button>
                    <button class="example-btn" onclick="loadExample('chang_e')">å«¦å¨¥å¥”æœˆ</button>
                    <button class="example-btn" onclick="loadExample('nezha')">å“ªå’é¬§æµ·</button>
                    <button class="example-btn" onclick="loadExample('susanoo')">é ˆä½ä¹‹ç”·</button>
                </div>
            </div>

            <!-- AIè¨­ç½® -->
            <div class="panel">
                <h3 class="panel-title">
                    <span>ğŸ¨</span>
                    <span>æ¼«ç•«è¨­ç½®</span>
                </h3>

                <div class="config-group">
                    <label class="config-label">ç•«é¢¨é¸æ“‡</label>
                    <select class="config-select" id="artStyle">
                        <option value="manga">æ—¥å¼æ¼«ç•«é¢¨æ ¼</option>
                        <option value="chinese">ä¸­åœ‹æ°´å¢¨é¢¨</option>
                        <option value="realistic">å¯«å¯¦æ’ç•«é¢¨</option>
                        <option value="anime">å‹•æ¼«é¢¨æ ¼</option>
                        <option value="mythical">ç¥è©±å¹»æƒ³é¢¨</option>
                        <option value="watercolor">æ°´å½©ç•«é¢¨</option>
                    </select>
                </div>

                <div class="config-group">
                    <label class="config-label">åˆ†é¡æ•¸é‡</label>
                    <select class="config-select" id="panelCount">
                        <option value="4">4æ ¼ (ç°¡çŸ­)</option>
                        <option value="6" selected>6æ ¼ (æ¨™æº–)</option>
                        <option value="8">8æ ¼ (è©³ç´°)</option>
                        <option value="12">12æ ¼ (å®Œæ•´)</option>
                    </select>
                </div>

                <div class="config-group">
                    <label class="config-label">åœ–åƒç”Ÿæˆæ–¹å¼</label>
                    <select class="config-select" id="imageGenerator">
                        <option value="demo">æ¼”ç¤ºæ¨¡å¼ (é è¦½)</option>
                        <option value="dalle3">DALL-E 3 (éœ€API Key)</option>
                        <option value="stable-diffusion">Stable Diffusion</option>
                        <option value="midjourney">Midjourneyæç¤ºè©</option>
                        <option value="local-sd">æœ¬åœ°SD (éœ€å®‰è£)</option>
                    </select>
                </div>

                <div class="config-group" id="apiKeyGroup" style="display: none;">
                    <label class="config-label">API Key</label>
                    <input type="password" class="config-input" id="apiKey" placeholder="è¼¸å…¥æ‚¨çš„API Key">
                </div>

                <button class="generate-btn" id="generateBtn" onclick="generateComic()">
                    ğŸ¬ ç”Ÿæˆæ¼«ç•«
                </button>
            </div>

            <!-- åˆ†é¡è…³æœ¬ -->
            <div class="panel">
                <h3 class="panel-title">
                    <span>ğŸ¬</span>
                    <span>AIåˆ†é¡è…³æœ¬</span>
                </h3>
                <div id="storyboardPreview" style="font-size: 0.9em; line-height: 1.6; color: #ccc;">
                    ç­‰å¾…ç”Ÿæˆåˆ†é¡...
                </div>
            </div>
        </div>

        <!-- æ¼«ç•«å±•ç¤ºå€ -->
        <div class="comic-area">
            <div class="comic-header">
                <h2 class="comic-title">æ¼«ç•«é è¦½</h2>
                <div class="view-controls">
                    <button class="view-btn active" onclick="switchView('grid')">ç¶²æ ¼</button>
                    <button class="view-btn" onclick="switchView('storyboard')">åˆ†é¡</button>
                    <button class="view-btn" onclick="switchView('manga')">æ¼«ç•«</button>
                </div>
            </div>

            <!-- ç¶²æ ¼è¦–åœ– -->
            <div class="comic-grid" id="comicGrid">
                <div class="comic-panel">
                    <div class="panel-image">
                        <div class="panel-placeholder">
                            <div style="font-size: 3em; margin-bottom: 10px;">ğŸ¨</div>
                            <div>ç­‰å¾…ç”Ÿæˆæ¼«ç•«...</div>
                            <div style="font-size: 0.9em; margin-top: 10px; opacity: 0.7;">
                                è¼¸å…¥æ•…äº‹ä¸¦é»æ“Š"ç”Ÿæˆæ¼«ç•«"é–‹å§‹
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- åˆ†é¡è¦–åœ– -->
            <div class="storyboard-view" id="storyboardView">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>

            <!-- æ¼«ç•«ç‰ˆå¼ -->
            <div class="manga-layout" id="mangaLayout">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <!-- åŠ è¼‰è¦†è“‹å±¤ -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">AIæ­£åœ¨å‰µä½œæ‚¨çš„ç¥è©±æ¼«ç•«...</div>
            <div class="loading-progress" id="loadingProgress">åˆ†ææ•…äº‹çµæ§‹...</div>
        </div>
    </div>

    <!-- å°å‡ºæ§åˆ¶ -->
    <div class="export-controls" id="exportControls" style="display: none;">
        <button class="export-btn" onclick="exportAsImage()">ğŸ“¥ å°å‡ºåœ–ç‰‡</button>
        <button class="export-btn" onclick="exportAsPDF()">ğŸ“„ å°å‡ºPDF</button>
        <button class="export-btn" onclick="shareComic()">ğŸ”— åˆ†äº«</button>
    </div>

    <script>
        // ==================== æ¼«ç•«ç”Ÿæˆç³»çµ±æ ¸å¿ƒ ====================
        
        class ComicGenerator {
            constructor() {
                this.currentStory = '';
                this.storyboard = [];
                this.generatedImages = [];
                this.artStyle = 'manga';
                this.panelCount = 6;
                this.imageGenerator = 'demo';
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // åœ–åƒç”Ÿæˆæ–¹å¼åˆ‡æ›
                document.getElementById('imageGenerator').addEventListener('change', (e) => {
                    const needsKey = ['dalle3', 'stable-diffusion'].includes(e.target.value);
                    document.getElementById('apiKeyGroup').style.display = needsKey ? 'block' : 'none';
                });
                
                // å…¶ä»–è¨­ç½®
                document.getElementById('artStyle').addEventListener('change', (e) => {
                    this.artStyle = e.target.value;
                });
                
                document.getElementById('panelCount').addEventListener('change', (e) => {
                    this.panelCount = parseInt(e.target.value);
                });
            }
            
            async generateComic() {
                const storyText = document.getElementById('storyInput').value.trim();
                if (!storyText) {
                    alert('è«‹è¼¸å…¥æ•…äº‹å…§å®¹');
                    return;
                }
                
                this.currentStory = storyText;
                this.showLoading(true, 'åˆ†ææ•…äº‹çµæ§‹...');
                
                try {
                    // Step 1: ç”Ÿæˆåˆ†é¡è…³æœ¬
                    this.updateProgress('ç”Ÿæˆåˆ†é¡è…³æœ¬...');
                    this.storyboard = await this.generateStoryboard(storyText);
                    this.displayStoryboard();
                    
                    // Step 2: ç”Ÿæˆåœ–åƒæç¤ºè©
                    this.updateProgress('å„ªåŒ–åœ–åƒæç¤ºè©...');
                    const prompts = await this.generateImagePrompts();
                    
                    // Step 3: ç”Ÿæˆåœ–åƒ
                    this.updateProgress('AIç¹ªè£½åœ–åƒä¸­...');
                    await this.generateImages(prompts);
                    
                    // Step 4: çµ„åˆæˆæ¼«ç•«
                    this.updateProgress('çµ„åˆæ¼«ç•«é é¢...');
                    this.assembleComic();
                    
                    // å®Œæˆ
                    this.showLoading(false);
                    document.getElementById('exportControls').style.display = 'flex';
                    
                } catch (error) {
                    console.error('ç”Ÿæˆå¤±æ•—:', error);
                    this.showLoading(false);
                    alert('ç”Ÿæˆéç¨‹å‡ºéŒ¯: ' + error.message);
                }
            }
            
            async generateStoryboard(story) {
                // ä½¿ç”¨æœ¬åœ°Qwen2ç”Ÿæˆåˆ†é¡
                if (window.ollama && this.imageGenerator !== 'demo') {
                    try {
                        const response = await fetch('http://localhost:11434/api/generate', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: 'qwen2:7b',
                                prompt: `è«‹å°‡ä»¥ä¸‹ç¥è©±æ•…äº‹åˆ†è§£ç‚º${this.panelCount}å€‹æ¼«ç•«åˆ†é¡ï¼Œæ¯å€‹åˆ†é¡åŒ…å«å ´æ™¯æè¿°ã€äººç‰©å‹•ä½œã€å°è©±ã€‚

æ•…äº‹ï¼š${story}

è«‹ç”¨JSONæ ¼å¼è¿”å›ï¼š
[
  {
    "panel": 1,
    "scene": "å ´æ™¯æè¿°",
    "characters": "äººç‰©å’Œå‹•ä½œ",
    "dialogue": "å°è©±æˆ–æ—ç™½",
    "mood": "æƒ…ç·’æ°›åœ",
    "camera": "é¡é ­è§’åº¦"
  }
]`,
                                stream: false,
                                options: { temperature: 0.7 }
                            })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            const jsonMatch = data.response.match(/\[[\s\S]*?\]/);
                            if (jsonMatch) {
                                return JSON.parse(jsonMatch[0]);
                            }
                        }
                    } catch (e) {
                        console.warn('Qwen2åˆ†é¡ç”Ÿæˆå¤±æ•—ï¼Œä½¿ç”¨æ™ºèƒ½åˆ†é¡');
                    }
                }
                
                // æ™ºèƒ½åˆ†é¡ç®—æ³•
                return this.intelligentStoryboard(story);
            }
            
            intelligentStoryboard(story) {
                const sentences = story.split(/[ã€‚ï¼ï¼Ÿ\n]/).filter(s => s.trim());
                const panelsPerSentence = Math.ceil(this.panelCount / sentences.length);
                const storyboard = [];
                
                sentences.forEach((sentence, idx) => {
                    // åˆ†æå¥å­å…§å®¹
                    const hasAction = /è·‘|èµ°|é£›|æˆ°|æ‰“|è·³|è¿½/.test(sentence);
                    const hasDialogue = /èªª|é“|å–Š|å«/.test(sentence);
                    const hasEmotion = /æ€’|å–œ|æ‚²|é©š|æ/.test(sentence);
                    
                    // æ ¹æ“šå…§å®¹æ±ºå®šåˆ†é¡æ•¸
                    const panels = hasAction ? Math.min(2, panelsPerSentence) : 1;
                    
                    for (let i = 0; i < panels; i++) {
                        storyboard.push({
                            panel: storyboard.length + 1,
                            scene: this.extractScene(sentence),
                            characters: this.extractCharacters(sentence),
                            dialogue: hasDialogue ? this.extractDialogue(sentence) : '',
                            mood: this.detectMood(sentence),
                            camera: hasAction ? (i === 0 ? 'wide' : 'close-up') : 'medium'
                        });
                    }
                });
                
                // ç¢ºä¿é”åˆ°ç›®æ¨™åˆ†é¡æ•¸
                while (storyboard.length < this.panelCount) {
                    const lastPanel = storyboard[storyboard.length - 1];
                    storyboard.push({
                        ...lastPanel,
                        panel: storyboard.length + 1,
                        camera: 'close-up'
                    });
                }
                
                return storyboard.slice(0, this.panelCount);
            }
            
            extractScene(text) {
                if (text.includes('å±±')) return 'é«˜è³çš„å±±è„ˆï¼Œé›²éœ§ç¹šç¹';
                if (text.includes('æµ·')) return 'æ³¢æ¿¤æ´¶æ¹§çš„å¤§æµ·';
                if (text.includes('å¤©')) return 'é¼é—Šçš„å¤©ç©º';
                if (text.includes('æ£®æ—')) return 'èŒ‚å¯†çš„åŸå§‹æ£®æ—';
                if (text.includes('å®®')) return 'è¯éº—çš„å®®æ®¿';
                return 'ç¥è©±ä¸–ç•Œçš„å ´æ™¯';
            }
            
            extractCharacters(text) {
                const characters = [];
                if (text.includes('å¤¸çˆ¶')) characters.push('å·¨äººå¤¸çˆ¶');
                if (text.includes('å¤ªé™½')) characters.push('ç†¾ç†±çš„å¤ªé™½');
                if (text.includes('å«¦å¨¥')) characters.push('ç¾éº—çš„å«¦å¨¥');
                if (text.includes('å“ªå’')) characters.push('å°‘å¹´è‹±é›„å“ªå’');
                if (text.includes('é¾')) characters.push('å¨åš´çš„é¾');
                
                return characters.length > 0 ? characters.join('ã€') : 'ç¥è©±äººç‰©';
            }
            
            extractDialogue(text) {
                const dialogueMatch = text.match(/[ã€Œ"](.*?)[ã€"]/);
                return dialogueMatch ? dialogueMatch[1] : '';
            }
            
            detectMood(text) {
                if (/æ¿€çƒˆ|æ†¤æ€’|æˆ°/.test(text)) return 'intense';
                if (/æ‚²å‚·|å“€|æ­»/.test(text)) return 'sad';
                if (/å–œ|æ¨‚|ç¬‘/.test(text)) return 'happy';
                if (/æ|æ€•|é©š/.test(text)) return 'fearful';
                return 'neutral';
            }
            
            async generateImagePrompts() {
                const stylePrompts = {
                    'manga': 'manga style, black and white with screentones, dynamic action lines',
                    'chinese': 'traditional Chinese ink painting style, watercolor, elegant brushstrokes',
                    'realistic': 'photorealistic illustration, detailed, cinematic lighting',
                    'anime': 'anime style, vibrant colors, expressive characters',
                    'mythical': 'fantasy art style, magical atmosphere, ethereal lighting',
                    'watercolor': 'watercolor painting, soft colors, artistic blur'
                };
                
                const baseStyle = stylePrompts[this.artStyle];
                
                return this.storyboard.map(panel => {
                    const prompt = `${baseStyle}, ${panel.scene}, ${panel.characters}, ${panel.mood} mood, ${panel.camera} shot, mythology illustration, high quality artwork`;
                    
                    // æ·»åŠ è² é¢æç¤ºè©
                    const negativePrompt = 'low quality, blurry, distorted, ugly, bad anatomy, text, watermark';
                    
                    return { 
                        positive: prompt, 
                        negative: negativePrompt,
                        panel: panel
                    };
                });
            }
            
            async generateImages(prompts) {
                this.generatedImages = [];
                
                for (let i = 0; i < prompts.length; i++) {
                    this.updateProgress(`ç”Ÿæˆç¬¬ ${i + 1}/${prompts.length} å¹…åœ–åƒ...`);
                    
                    switch (this.imageGenerator) {
                        case 'dalle3':
                            this.generatedImages.push(await this.generateWithDalle(prompts[i]));
                            break;
                        case 'stable-diffusion':
                            this.generatedImages.push(await this.generateWithSD(prompts[i]));
                            break;
                        case 'local-sd':
                            this.generatedImages.push(await this.generateWithLocalSD(prompts[i]));
                            break;
                        case 'midjourney':
                            this.generatedImages.push(this.generateMidjourneyPrompt(prompts[i]));
                            break;
                        default:
                            this.generatedImages.push(this.generateDemoImage(prompts[i], i));
                    }
                    
                    // å»¶é²é¿å…APIé™åˆ¶
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
            async generateWithDalle(prompt) {
                const apiKey = document.getElementById('apiKey').value;
                if (!apiKey) throw new Error('è«‹æä¾›OpenAI API Key');
                
                const response = await fetch('https://api.openai.com/v1/images/generations', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: "dall-e-3",
                        prompt: prompt.positive,
                        n: 1,
                        size: "1024x1024",
                        quality: "standard",
                        style: "vivid"
                    })
                });
                
                if (!response.ok) throw new Error('DALL-E 3 APIéŒ¯èª¤');
                
                const data = await response.json();
                return data.data[0].url;
            }
            
            async generateWithSD(prompt) {
                // Stable Diffusion API (ä¾‹å¦‚ Replicate)
                const apiKey = document.getElementById('apiKey').value;
                if (!apiKey) throw new Error('è«‹æä¾›Stable Diffusion API Key');
                
                // é€™è£¡ä½¿ç”¨Replicate APIä½œç‚ºç¤ºä¾‹
                const response = await fetch('https://api.replicate.com/v1/predictions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Token ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        version: "stability-ai/sdxl:latest",
                        input: {
                            prompt: prompt.positive,
                            negative_prompt: prompt.negative,
                            width: 1024,
                            height: 1024,
                            num_inference_steps: 30
                        }
                    })
                });
                
                if (!response.ok) throw new Error('Stable Diffusion APIéŒ¯èª¤');
                
                const prediction = await response.json();
                // ç­‰å¾…ç”Ÿæˆå®Œæˆ
                return await this.waitForSDResult(prediction.id, apiKey);
            }
            
            async waitForSDResult(predictionId, apiKey) {
                // è¼ªè©¢æª¢æŸ¥ç”Ÿæˆç‹€æ…‹
                for (let i = 0; i < 60; i++) {
                    const response = await fetch(`https://api.replicate.com/v1/predictions/${predictionId}`, {
                        headers: { 'Authorization': `Token ${apiKey}` }
                    });
                    
                    const result = await response.json();
                    if (result.status === 'succeeded') {
                        return result.output[0];
                    } else if (result.status === 'failed') {
                        throw new Error('åœ–åƒç”Ÿæˆå¤±æ•—');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                throw new Error('ç”Ÿæˆè¶…æ™‚');
            }
            
            async generateWithLocalSD(prompt) {
                // æª¢æ¸¬æœ¬åœ°Stable Diffusion WebUIå¯ç”¨æ€§
                try {
                    // é¦–å…ˆæª¢æŸ¥SD WebUIæ˜¯å¦é‹è¡Œ
                    const healthCheck = await fetch('http://localhost:7860/sdapi/v1/progress', {
                        method: 'GET',
                        timeout: 3000
                    });
                    
                    if (!healthCheck.ok) {
                        throw new Error('Stable Diffusion WebUIæœªé‹è¡Œ');
                    }
                } catch (error) {
                    throw new Error(`ç„¡æ³•é€£æ¥åˆ°æœ¬åœ°SD WebUI (http://localhost:7860)ã€‚è«‹ç¢ºä¿ï¼š
1. å·²å•Ÿå‹• Stable Diffusion WebUI
2. ä½¿ç”¨ --api åƒæ•¸å•Ÿå‹•
3. é—œé–‰é˜²ç«ç‰†æˆ–æ·»åŠ ä¾‹å¤–
4. æª¢æŸ¥ç«¯å£7860æ˜¯å¦è¢«ä½”ç”¨`);
                }
                
                // å¢å¼·çš„åœ–ç‰‡ç”Ÿæˆåƒæ•¸
                const sdParams = {
                    prompt: this.enhanceSDPrompt(prompt.positive),
                    negative_prompt: prompt.negative + ', low quality, blurry, distorted, deformed, bad anatomy, mutilated, poorly drawn face',
                    steps: 25, // é©ä¸­çš„æ­¥æ•¸ï¼Œå¹³è¡¡è³ªé‡å’Œé€Ÿåº¦
                    width: 512,
                    height: 512,
                    cfg_scale: 8, // è¼ƒé«˜çš„å¼•å°å°ºåº¦ç¢ºä¿è³ªé‡
                    sampler_name: "DPM++ 2M Karras",
                    seed: -1, // éš¨æ©Ÿç¨®å­
                    restore_faces: true, // ä¿®å¾©é¢éƒ¨
                    enable_hr: false, // é«˜è§£æåº¦ä¿®å¾©
                    hr_scale: 1.5,
                    hr_upscaler: "Latent",
                    hr_second_pass_steps: 15,
                    batch_size: 1,
                    n_iter: 1
                };
                
                // æ ¹æ“šè—è¡“é¢¨æ ¼èª¿æ•´åƒæ•¸
                if (this.artStyle === 'manga') {
                    sdParams.width = 512;
                    sdParams.height = 768; // æ¼«ç•«æ ¼å¼æ›´é«˜
                } else if (this.artStyle === 'chinese') {
                    sdParams.cfg_scale = 7; // ä¸­åœ‹æ°´å¢¨ç•«éœ€è¦è¼ƒä½çš„å¼•å°
                    sdParams.steps = 30; // æ›´å¤šæ­¥æ•¸ç²å¾—ç´°è†©æ•ˆæœ
                }
                
                const response = await fetch('http://localhost:7860/sdapi/v1/txt2img', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(sdParams)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`SD WebUIéŒ¯èª¤ (${response.status}): ${errorText}`);
                }
                
                const data = await response.json();
                
                if (!data.images || data.images.length === 0) {
                    throw new Error('SD WebUIè¿”å›äº†ç©ºçš„åœ–åƒæ•¸çµ„');
                }
                
                // æª¢æŸ¥ç”Ÿæˆçš„åœ–åƒæ˜¯å¦æœ‰æ•ˆ
                const imageBase64 = data.images[0];
                if (!imageBase64 || imageBase64.length < 100) {
                    throw new Error('ç”Ÿæˆçš„åœ–åƒæ•¸æ“šç„¡æ•ˆ');
                }
                
                return 'data:image/png;base64,' + imageBase64;
            }
            
            enhanceSDPrompt(originalPrompt) {
                // æ ¹æ“šä¸åŒé¢¨æ ¼å¢å¼·æç¤ºè©
                const styleEnhancements = {
                    'manga': 'manga style, anime, black and white, screentone, dynamic pose, expressive',
                    'chinese': 'traditional Chinese painting, ink wash, elegant brushstrokes, classical style',
                    'realistic': 'photorealistic, highly detailed, professional photography, cinematic lighting',
                    'anime': 'anime style, cel shading, vibrant colors, expressive eyes',
                    'mythical': 'fantasy art, mythological, magical atmosphere, epic composition',
                    'watercolor': 'watercolor painting, soft colors, artistic brush texture'
                };
                
                const enhancement = styleEnhancements[this.artStyle] || 'high quality, detailed';
                
                // æ·»åŠ é€šç”¨è³ªé‡æå‡è©
                const qualityBoosts = 'masterpiece, best quality, ultra-detailed, sharp focus, professional artwork';
                
                return `${enhancement}, ${originalPrompt}, ${qualityBoosts}`;
            }
            
            async testLocalSDConnection() {
                try {
                    const response = await fetch('http://localhost:7860/sdapi/v1/options', {
                        method: 'GET',
                        timeout: 5000
                    });
                    
                    if (response.ok) {
                        const options = await response.json();
                        console.log('SD WebUIå·²é€£æ¥ï¼Œç•¶å‰æ¨¡å‹:', options.sd_model_checkpoint || 'æœªçŸ¥');
                        return { 
                            connected: true, 
                            model: options.sd_model_checkpoint,
                            version: options.version || 'æœªçŸ¥'
                        };
                    }
                } catch (error) {
                    console.warn('SD WebUIé€£æ¥æ¸¬è©¦å¤±æ•—:', error);
                }
                
                return { connected: false, error: 'ç„¡æ³•é€£æ¥åˆ°SD WebUI' };
            }
            
            async getSDModels() {
                try {
                    const response = await fetch('http://localhost:7860/sdapi/v1/sd-models');
                    if (response.ok) {
                        const models = await response.json();
                        return models.map(m => ({
                            name: m.model_name,
                            title: m.title,
                            filename: m.filename
                        }));
                    }
                } catch (error) {
                    console.warn('ç²å–SDæ¨¡å‹åˆ—è¡¨å¤±æ•—:', error);
                }
                return [];
            }
            
            generateMidjourneyPrompt(prompt) {
                // ç”ŸæˆMidjourneyæç¤ºè©ä¾›ç”¨æˆ¶è¤‡è£½
                const mjPrompt = `/imagine prompt: ${prompt.positive} --ar 1:1 --v 6 --style raw`;
                return {
                    type: 'midjourney',
                    prompt: mjPrompt,
                    instruction: 'è«‹è¤‡è£½æ­¤æç¤ºè©åˆ°Discordä¸­çš„Midjourney Bot'
                };
            }
            
            generateDemoImage(prompt, index) {
                // æ¼”ç¤ºæ¨¡å¼ï¼šä½¿ç”¨Canvasç”Ÿæˆæ›´ä¸°å¯Œçš„é¢„è§ˆå›¾
                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // èƒŒæ™¯é¢œè‰²å’Œæ¸å˜
                const colors = [
                    ['#ff6b6b', '#ee5a6f'], // çº¢è‰²æ¸å˜
                    ['#4ecdc4', '#44a08d'], // é’è‰²æ¸å˜  
                    ['#45b7d1', '#96c93d'], // è“ç»¿æ¸å˜
                    ['#96ceb4', '#ffecd2'], // ç»¿è‰²æ¸å˜
                    ['#ffeaa7', '#fab2d0'], // é»„ç²‰æ¸å˜
                    ['#dfe6e9', '#b2bec3']  // ç°è‰²æ¸å˜
                ];
                
                const [color1, color2] = colors[index % colors.length];
                
                // åˆ›å»ºæ¸å˜èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, 400, 400);
                gradient.addColorStop(0, color1);
                gradient.addColorStop(1, color2);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 400, 400);
                
                // æ·»åŠ ç¥è¯ä¸»é¢˜è£…é¥°
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                this.drawMythologyPattern(ctx, prompt.panel, index);
                
                // åœºæ™¯æ ‡é¢˜
                ctx.fillStyle = 'white';
                ctx.font = 'bold 28px Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`ç¬¬ ${index + 1} æ ¼`, 200, 60);
                
                // åœºæ™¯æè¿° - åˆ†è¡Œæ˜¾ç¤º
                ctx.font = '16px Arial, sans-serif';
                const scene = prompt.panel.scene;
                const lines = this.wrapText(scene, 350, ctx);
                let y = 150;
                
                lines.forEach((line, idx) => {
                    if (idx < 4) { // æœ€å¤šæ˜¾ç¤º4è¡Œ
                        ctx.fillText(line, 200, y + idx * 25);
                    }
                });
                
                // äººç‰©ä¿¡æ¯
                ctx.font = '14px Arial, sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(`è§’è‰²: ${prompt.panel.characters}`, 200, 280);
                
                // æ°›å›´æ ‡è¯†
                const moodColors = {
                    'intense': 'ğŸ”¥ æ¿€çƒˆ',
                    'sad': 'ğŸ˜¢ æ‚²ä¼¤', 
                    'happy': 'ğŸ˜Š æ¬¢ä¹',
                    'fearful': 'ğŸ˜¨ ææƒ§',
                    'neutral': 'ğŸ˜ å¹³é™'
                };
                
                const moodText = moodColors[prompt.panel.mood] || 'ğŸ˜ ç¥ç§˜';
                ctx.fillText(`æ°›å›´: ${moodText}`, 200, 310);
                
                // é•œå¤´ä¿¡æ¯
                const cameraText = {
                    'wide': 'å¹¿è§’é•œå¤´',
                    'close-up': 'ç‰¹å†™é•œå¤´', 
                    'medium': 'ä¸­æ™¯é•œå¤´'
                };
                ctx.fillText(`é•œå¤´: ${cameraText[prompt.panel.camera] || 'æ ‡å‡†'}`, 200, 340);
                
                // æ¼”ç¤ºæ ‡è¯†
                ctx.font = 'italic 12px Arial, sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillText('[AIæ¼”ç¤ºé¢„è§ˆ - å®é™…ç”Ÿæˆä¼šæ›´ç²¾ç¾]', 200, 380);
                
                return canvas.toDataURL('image/png');
            }
            
            drawMythologyPattern(ctx, panel, index) {
                // æ ¹æ®åœºæ™¯å†…å®¹ç»˜åˆ¶ä¸åŒçš„è£…é¥°å›¾æ¡ˆ
                const scene = panel.scene.toLowerCase();
                
                if (scene.includes('å±±') || scene.includes('mountain')) {
                    this.drawMountainPattern(ctx);
                } else if (scene.includes('æµ·') || scene.includes('æ°´') || scene.includes('water')) {
                    this.drawWavePattern(ctx);
                } else if (scene.includes('å¤©') || scene.includes('cloud')) {
                    this.drawCloudPattern(ctx);
                } else if (scene.includes('é¾™') || scene.includes('dragon')) {
                    this.drawDragonPattern(ctx);
                } else {
                    this.drawStarPattern(ctx, index);
                }
            }
            
            drawMountainPattern(ctx) {
                // ç»˜åˆ¶å±±å½¢å›¾æ¡ˆ
                ctx.beginPath();
                ctx.moveTo(50, 350);
                ctx.lineTo(100, 250);
                ctx.lineTo(150, 280);
                ctx.lineTo(200, 200);
                ctx.lineTo(250, 260);
                ctx.lineTo(300, 220);
                ctx.lineTo(350, 350);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            drawWavePattern(ctx) {
                // ç»˜åˆ¶æ³¢æµªå›¾æ¡ˆ
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    const y = 320 + i * 20;
                    ctx.moveTo(0, y);
                    for (let x = 0; x <= 400; x += 20) {
                        ctx.quadraticCurveTo(x + 10, y - 10, x + 20, y);
                    }
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 - i * 0.1})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            drawCloudPattern(ctx) {
                // ç»˜åˆ¶äº‘æœµå›¾æ¡ˆ
                for (let i = 0; i < 4; i++) {
                    const x = 50 + i * 80;
                    const y = 80 + Math.sin(i) * 20;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 15, 0, Math.PI * 2);
                    ctx.arc(x + 20, y, 20, 0, Math.PI * 2);
                    ctx.arc(x + 40, y, 15, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fill();
                }
            }
            
            drawDragonPattern(ctx) {
                // ç»˜åˆ¶ç®€åŒ–é¾™é³å›¾æ¡ˆ
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const x = 50 + i * 40;
                        const y = 50 + j * 40;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 8, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.1 + (i + j) * 0.01})`;
                        ctx.fill();
                    }
                }
            }
            
            drawStarPattern(ctx, seed) {
                // ç»˜åˆ¶æ˜Ÿæ˜Ÿå›¾æ¡ˆ
                for (let i = 0; i < 20; i++) {
                    const x = (seed * 37 + i * 73) % 400;
                    const y = (seed * 23 + i * 91) % 400;
                    const size = 2 + (i % 3);
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.random() * 0.4})`;
                    this.drawStar(ctx, x, y, size);
                }
            }
            
            drawStar(ctx, x, y, size) {
                ctx.save();
                ctx.translate(x, y);
                ctx.beginPath();
                ctx.moveTo(0, -size);
                for (let i = 0; i < 5; i++) {
                    ctx.rotate(Math.PI / 5);
                    ctx.lineTo(0, -size * 0.5);
                    ctx.rotate(Math.PI / 5);
                    ctx.lineTo(0, -size);
                }
                ctx.fill();
                ctx.restore();
            }
            
            wrapText(text, maxWidth, ctx) {
                const words = text.split('');
                const lines = [];
                let currentLine = '';
                
                for (let word of words) {
                    const testLine = currentLine + word;
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && currentLine !== '') {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                }
                
                if (currentLine) {
                    lines.push(currentLine);
                }
                
                return lines;
            }
            
            displayStoryboard() {
                const preview = document.getElementById('storyboardPreview');
                preview.innerHTML = this.storyboard.map((panel, idx) => `
                    <div style="margin-bottom: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px;">
                        <strong style="color: #ffd700;">ç¬¬${panel.panel}æ ¼:</strong> ${panel.scene}<br>
                        <small style="opacity: 0.8;">äººç‰©: ${panel.characters} | æ°›åœ: ${panel.mood}</small>
                    </div>
                `).join('');
            }
            
            assembleComic() {
                // ç¶²æ ¼è¦–åœ–
                const grid = document.getElementById('comicGrid');
                grid.innerHTML = this.generatedImages.map((img, idx) => {
                    const panel = this.storyboard[idx];
                    
                    if (typeof img === 'object' && img.type === 'midjourney') {
                        return `
                            <div class="comic-panel">
                                <div class="panel-number">${idx + 1}</div>
                                <div class="panel-image">
                                    <div class="panel-placeholder">
                                        <div style="padding: 20px;">
                                            <div style="font-size: 1.5em; margin-bottom: 10px;">Midjourneyæç¤ºè©</div>
                                            <div style="font-family: monospace; font-size: 0.8em; background: rgba(0,0,0,0.1); padding: 10px; border-radius: 5px;">
                                                ${img.prompt}
                                            </div>
                                            <div style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
                                                ${img.instruction}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="panel-text">${panel.scene}</div>
                            </div>
                        `;
                    }
                    
                    return `
                        <div class="comic-panel">
                            <div class="panel-number">${idx + 1}</div>
                            <div class="panel-image">
                                <img src="${img}" alt="å ´æ™¯${idx + 1}">
                            </div>
                            <div class="panel-text">
                                ${panel.dialogue ? `<div class="speech-bubble">${panel.dialogue}</div>` : ''}
                                ${panel.scene}
                            </div>
                        </div>
                    `;
                }).join('');
                
                // åˆ†é¡è¦–åœ–
                const storyboard = document.getElementById('storyboardView');
                storyboard.innerHTML = this.storyboard.map((panel, idx) => `
                    <div class="storyboard-item">
                        <div class="storyboard-number">${panel.panel}</div>
                        <div class="storyboard-content">
                            <div class="storyboard-prompt">
                                é¡é ­: ${panel.camera} | æ°›åœ: ${panel.mood}
                            </div>
                            <div class="storyboard-description">
                                <strong>å ´æ™¯:</strong> ${panel.scene}<br>
                                <strong>äººç‰©:</strong> ${panel.characters}<br>
                                ${panel.dialogue ? `<strong>å°è©±:</strong> "${panel.dialogue}"` : ''}
                            </div>
                        </div>
                    </div>
                `).join('');
                
                // æ¼«ç•«ç‰ˆå¼
                this.generateMangaLayout();
            }
            
            generateMangaLayout() {
                const manga = document.getElementById('mangaLayout');
                const panels = this.generatedImages.map((img, idx) => ({
                    image: img,
                    panel: this.storyboard[idx],
                    index: idx
                }));
                
                // æ™ºèƒ½æ¼«ç•«æ’ç‰ˆç®—æ³•
                const rows = this.calculateMangaRows(panels.length);
                let panelIndex = 0;
                
                manga.innerHTML = rows.map(rowConfig => {
                    const rowPanels = panels.slice(panelIndex, panelIndex + rowConfig.panels);
                    panelIndex += rowConfig.panels;
                    
                    return `
                        <div class="manga-row" style="height: ${rowConfig.height}px;">
                            ${rowPanels.map((item, cellIdx) => {
                                const isLarge = rowConfig.layout[cellIdx] === 'large';
                                return this.createMangaCell(item, isLarge);
                            }).join('')}
                        </div>
                    `;
                }).join('');
            }
            
            calculateMangaRows(totalPanels) {
                // æ™ºèƒ½åˆ†é…æ¼«ç•«é é¢å¸ƒå±€
                const layouts = [
                    { panels: 1, height: 400, layout: ['large'] },
                    { panels: 2, height: 300, layout: ['medium', 'medium'] },
                    { panels: 2, height: 350, layout: ['large', 'small'] },
                    { panels: 3, height: 250, layout: ['small', 'small', 'small'] },
                    { panels: 3, height: 300, layout: ['large', 'small', 'small'] }
                ];
                
                const rows = [];
                let remaining = totalPanels;
                
                while (remaining > 0) {
                    let bestLayout;
                    
                    if (remaining === 1) {
                        bestLayout = layouts[0]; // å–®æ ¼å¤§åœ–
                    } else if (remaining === 2) {
                        bestLayout = Math.random() > 0.5 ? layouts[1] : layouts[2]; // éš¨æ©Ÿé¸æ“‡é›™æ ¼å¸ƒå±€
                    } else if (remaining >= 3) {
                        // æ ¹æ“šæƒ…ç¯€é¸æ“‡å¸ƒå±€
                        const currentPanelIndex = totalPanels - remaining;
                        const currentPanel = this.storyboard[currentPanelIndex];
                        
                        if (currentPanel && currentPanel.mood === 'intense') {
                            bestLayout = layouts[2]; // æ¿€çƒˆå ´é¢ç”¨å¤§æ ¼
                        } else {
                            bestLayout = layouts[Math.floor(Math.random() * 3) + 2]; // éš¨æ©Ÿé¸æ“‡
                        }
                    }
                    
                    rows.push(bestLayout);
                    remaining -= bestLayout.panels;
                }
                
                return rows;
            }
            
            createMangaCell(item, isLarge = false) {
                const { image, panel, index } = item;
                const sizeClass = isLarge ? 'manga-cell large' : 'manga-cell';
                
                if (typeof image === 'object' && image.type === 'midjourney') {
                    return `
                        <div class="${sizeClass}">
                            <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px;">
                                æ ¼å­ ${index + 1}
                            </div>
                            <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px 10px 10px; color: white;">
                                <div style="font-size: 0.8em; margin-bottom: 5px;">Midjourneyæç¤ºè©:</div>
                                <div style="font-family: monospace; font-size: 0.7em;">${image.prompt}</div>
                            </div>
                        </div>
                    `;
                }
                
                return `
                    <div class="${sizeClass}" style="background-image: url('${image}'); background-size: cover; background-position: center;">
                        <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px;">
                            ${index + 1}
                        </div>
                        
                        ${panel.dialogue ? `
                            <div style="position: absolute; top: 20px; right: 20px; background: white; border: 2px solid #333; border-radius: 15px; padding: 8px 12px; max-width: 120px; font-size: 0.8em; color: #333;">
                                <div style="position: absolute; bottom: -8px; left: 20px; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 8px solid white;"></div>
                                ${panel.dialogue}
                            </div>
                        ` : ''}
                        
                        ${panel.mood === 'intense' ? `
                            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(circle, transparent 60%, rgba(255,0,0,0.1) 100%); pointer-events: none;"></div>
                        ` : ''}
                        
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px 10px 10px; color: white;">
                            <div style="font-size: 0.8em; opacity: 0.9;">${panel.scene}</div>
                        </div>
                    </div>
                `;
            }
            
            showLoading(show, message = '') {
                const overlay = document.getElementById('loadingOverlay');
                overlay.classList.toggle('active', show);
                if (message) {
                    document.getElementById('loadingProgress').textContent = message;
                }
            }
            
            updateProgress(message) {
                document.getElementById('loadingProgress').textContent = message;
            }
        }
        
        // ==================== è¼”åŠ©å‡½æ•¸ ====================
        
        const comicGenerator = new ComicGenerator();
        
        function generateComic() {
            comicGenerator.generateComic();
        }
        
        function loadExample(type) {
            const examples = {
                'kuafu': `å¤¸çˆ¶æ˜¯é å¤æ™‚ä»£çš„å·¨äººï¼Œä»–çœ‹åˆ°å¤ªé™½æ¯å¤©å¾æ±æ–¹å‡èµ·ï¼Œè¥¿æ–¹è½ä¸‹ï¼Œçµ¦å¤§åœ°å¸¶ä¾†é»‘æš—ï¼Œæ±ºå¿ƒè¦è¿½ä¸Šå¤ªé™½ï¼Œè®“å…‰æ˜æ°¸é§äººé–“ã€‚
ä»–é‚é–‹å·¨å¤§çš„æ­¥ä¼é–‹å§‹å¥”è·‘ï¼Œä¸€æ­¥è·¨éä¸€åº§å±±ï¼Œå…©æ­¥è¶Šéä¸€æ¢æ²³ã€‚ä»–è¿½è‘—å¤ªé™½è·‘äº†å¾ˆä¹…ï¼Œè¶Šä¾†è¶Šè¿‘äº†ã€‚
å¯æ˜¯ä»–å¤ªæ¸´äº†ï¼Œä¾¿ä¿¯èº«å–ä¹¾äº†é»ƒæ²³æ°´ï¼Œåˆå–ä¹¾äº†æ¸­æ°´ï¼Œé‚„æ˜¯ä¸è§£æ¸´ã€‚ä»–æƒ³å»å–å¤§æ¾¤çš„æ°´ï¼Œä½†é‚„æ²’èµ°åˆ°ï¼Œå°±æ¸´æ­»åœ¨è·¯ä¸Šã€‚
å¤¸çˆ¶æ­»å¾Œï¼Œä»–çš„èº«è»€åŒ–ä½œäº†å¤§å±±ï¼Œæ‰‹æ–è®Šæˆäº†ä¸€ç‰‡æ¡ƒæ—ï¼Œç‚ºå¾Œä¾†çš„äººå€‘æä¾›ç”˜ç”œçš„æœå¯¦å’Œé™°æ¶¼ã€‚`,
                
                'chang_e': `åç¾¿å°„ä¸‹ä¹å€‹å¤ªé™½å¾Œï¼Œè¥¿ç‹æ¯è³œçµ¦ä»–ä¸€åŒ…ä¸æ­»è—¥ã€‚åç¾¿æ¨ä¸å¾—æ’‡ä¸‹å¦»å­å«¦å¨¥ï¼Œå°±æŠŠè—¥äº¤çµ¦å¥¹ä¿ç®¡ã€‚
ä¸€å¤©ï¼Œåç¾¿å¤–å‡ºç‹©çµï¼Œå«¦å¨¥ç¨è‡ªåœ¨å®¶ã€‚å¥¹æƒ³èµ·ä¸æ­»è—¥çš„äº‹ï¼Œå¿ä¸ä½æ‰“é–‹ä¾†çœ‹ã€‚
è—¥çš„é¦™å‘³æ’²é¼»è€Œä¾†ï¼Œå«¦å¨¥å¿ä¸ä½åƒäº†ä¸‹å»ã€‚é “æ™‚ï¼Œå¥¹æ„Ÿåˆ°èº«é«”è®Šè¼•ï¼Œä¸ç”±è‡ªä¸»åœ°é£„äº†èµ·ä¾†ã€‚
å¥¹é£›å‡ºçª—å¤–ï¼Œè¶Šé£›è¶Šé«˜ï¼Œä¸€ç›´é£›åˆ°äº†æœˆå®®ã€‚å¾æ­¤ï¼Œå«¦å¨¥ç¨è‡ªä½åœ¨æ¸…å†·çš„æœˆå®®ä¸­ï¼Œåªæœ‰ç‰å…”ç›¸ä¼´ã€‚æ¯ç•¶æœˆåœ“ä¹‹å¤œï¼Œå¥¹éƒ½æœƒæƒ³å¿µäººé–“çš„ä¸ˆå¤«ã€‚`,
                
                'nezha': `å“ªå’ä¸ƒæ­²æ™‚åœ¨æ±æµ·é‚Šæ´—æ¾¡ï¼Œä»–æŠŠæ··å¤©ç¶¾æ”¾åœ¨æ°´è£¡æ–æ™ƒï¼Œæ•´å€‹å¤§æµ·éƒ½éœ‡å‹•èµ·ä¾†ï¼Œé¾å®®ä¹Ÿæ–æ™ƒä¸æ­¢ã€‚
é¾ç‹æ´¾ä¸‰å¤ªå­æ•–ä¸™å‰ä¾†æŸ¥çœ‹ã€‚æ•–ä¸™çœ‹è¦‹æ˜¯å€‹å°å­©åœ¨æ—äº‚ï¼Œéå¸¸ç”Ÿæ°£ï¼Œèˆ‰æ§å°±åˆºã€‚
å“ªå’æ©Ÿéˆåœ°èº²é–‹ï¼Œç”¨æ··å¤©ç¶¾çºä½æ•–ä¸™çš„æ§ï¼Œåˆç”¨ä¹¾å¤åœˆæ‰“ä¸­æ•–ä¸™çš„é ­ã€‚æ•–ä¸™ç¾å‡ºé¾å½¢æƒ³è¦åæ“Šã€‚
å“ªå’æ¯«ä¸ç•æ‡¼ï¼Œè·³åˆ°é¾èº«ä¸Šï¼Œä¸€æ‹³æ‰“æ­»äº†æ•–ä¸™ï¼Œé‚„æŠ½äº†ä»–çš„é¾ç­‹ã€‚é¾ç‹çŸ¥é“å¾Œå¤§æ€’ï¼Œè¦æ°´æ·¹é™³å¡˜é—œã€‚`,
                
                'susanoo': `ç´ æˆ”å—šå°Šå› ç‚ºä½œæƒ¡è¢«é€å‡ºé«˜å¤©åŸï¼Œä¾†åˆ°äººé–“ã€‚ä»–è½èªªæœ‰å€‹å…«å²å¤§è›‡æ¯å¹´è¦åƒä¸€å€‹å°‘å¥³ï¼Œä»Šå¹´è¼ªåˆ°ç¾éº—çš„å¥‡ç¨»ç”°å§¬ã€‚
ç´ æˆ”å—šå°Šæ±ºå®šé™¤æ‰å¤§è›‡ã€‚ä»–è®“äººæº–å‚™äº†å…«æ¡¶çƒˆé…’ï¼Œæ”¾åœ¨å…«å€‹é–€å£ã€‚
å…«å²å¤§è›‡ä¾†äº†ï¼Œå®ƒæœ‰å…«å€‹é ­å…«æ¢å°¾ï¼Œèº«é«”é¾å¤§å¦‚å±±ã€‚çœ‹åˆ°ç¾é…’ï¼Œå…«å€‹é ­éƒ½ä¼¸éå»å–ï¼Œå¾ˆå¿«å°±é†‰å€’äº†ã€‚
ç´ æˆ”å—šå°Šæ‹”å‡ºåæ‹³åŠï¼Œå°‡å¤§è›‡çš„é ­ä¸€å€‹å€‹ç ä¸‹ï¼Œåˆæ–¬æ–·äº†å®ƒçš„å°¾å·´ã€‚åœ¨è›‡å°¾ä¸­ï¼Œä»–ç™¼ç¾äº†å‚³èªªä¸­çš„è‰è–™åŠã€‚`
            };
            
            document.getElementById('storyInput').value = examples[type] || '';
        }
        
        function switchView(view) {
            // åˆ‡æ›è¦–åœ–
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            document.getElementById('comicGrid').style.display = view === 'grid' ? 'grid' : 'none';
            document.getElementById('storyboardView').style.display = view === 'storyboard' ? 'block' : 'none';
            document.getElementById('mangaLayout').style.display = view === 'manga' ? 'block' : 'none';
        }
        
        async function exportAsImage() {
            try {
                const activeView = document.querySelector('.view-btn.active').textContent;
                let targetElement;
                
                if (activeView === 'ç¶²æ ¼') {
                    targetElement = document.getElementById('comicGrid');
                } else if (activeView === 'åˆ†é¡') {
                    targetElement = document.getElementById('storyboardView');
                } else {
                    targetElement = document.getElementById('mangaLayout');
                }
                
                if (!targetElement || targetElement.children.length === 0) {
                    alert('è«‹å…ˆç”Ÿæˆæ¼«ç•«å…§å®¹');
                    return;
                }
                
                // ä½¿ç”¨html2canvaså°å‡ºåœ–ç‰‡
                const canvas = await html2canvas(targetElement, {
                    backgroundColor: '#ffffff',
                    scale: 2, // æé«˜è§£æåº¦
                    useCORS: true,
                    allowTaint: true,
                    imageTimeout: 0,
                    logging: false
                });
                
                // å‰µå»ºä¸‹è¼‰é€£çµ
                const link = document.createElement('a');
                link.download = `mythology-comic-${activeView}-${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png');
                
                // è§¸ç™¼ä¸‹è¼‰
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // é¡¯ç¤ºæˆåŠŸè¨Šæ¯
                showNotification('åœ–ç‰‡å°å‡ºæˆåŠŸï¼', 'success');
                
            } catch (error) {
                console.error('åœ–ç‰‡å°å‡ºå¤±æ•—:', error);
                alert('åœ–ç‰‡å°å‡ºå¤±æ•—ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨ç›¸å®¹æ€§');
            }
        }
        
        async function exportAsPDF() {
            try {
                // æª¢æŸ¥æ˜¯å¦æœ‰å…§å®¹
                if (!comicGenerator.generatedImages.length) {
                    alert('è«‹å…ˆç”Ÿæˆæ¼«ç•«å…§å®¹');
                    return;
                }
                
                // å‰µå»ºæ–°çš„jsPDFå¯¦ä¾‹
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 10;
                
                // æ·»åŠ æ¨™é¡Œé 
                pdf.setFontSize(24);
                pdf.text('AIç¥è©±æ¼«ç•«ä½œå“', pageWidth / 2, 30, { align: 'center' });
                
                pdf.setFontSize(12);
                const story = document.getElementById('storyInput').value;
                const storyTitle = story.substring(0, 50) + (story.length > 50 ? '...' : '');
                pdf.text(storyTitle, pageWidth / 2, 50, { align: 'center' });
                
                pdf.setFontSize(10);
                pdf.text(`ç”Ÿæˆæ™‚é–“: ${new Date().toLocaleString('zh-TW')}`, pageWidth / 2, 70, { align: 'center' });
                
                // ç­‰å¾…æ‰€æœ‰åœ–ç‰‡è¼‰å…¥
                const imagePromises = comicGenerator.generatedImages.map((img, idx) => {
                    if (typeof img === 'object' && img.type === 'midjourney') {
                        return Promise.resolve({ type: 'text', content: img.prompt, panel: comicGenerator.storyboard[idx] });
                    }
                    
                    return new Promise((resolve, reject) => {
                        const image = new Image();
                        image.crossOrigin = 'anonymous';
                        image.onload = () => resolve({ type: 'image', element: image, panel: comicGenerator.storyboard[idx] });
                        image.onerror = () => resolve({ type: 'error', panel: comicGenerator.storyboard[idx] });
                        image.src = img;
                    });
                });
                
                const loadedImages = await Promise.all(imagePromises);
                
                // ç‚ºæ¯å€‹æ ¼å­å‰µå»ºä¸€é 
                for (let i = 0; i < loadedImages.length; i++) {
                    const item = loadedImages[i];
                    
                    if (i > 0) pdf.addPage();
                    
                    // é é¢æ¨™é¡Œ
                    pdf.setFontSize(16);
                    pdf.text(`ç¬¬ ${i + 1} æ ¼`, margin, 20);
                    
                    let yPos = 40;
                    
                    if (item.type === 'image') {
                        // æ·»åŠ åœ–ç‰‡
                        const imgWidth = pageWidth - 2 * margin;
                        const imgHeight = (item.element.height / item.element.width) * imgWidth;
                        const maxHeight = pageHeight - 100;
                        
                        const finalHeight = Math.min(imgHeight, maxHeight);
                        const finalWidth = (finalHeight / imgHeight) * imgWidth;
                        
                        pdf.addImage(item.element, 'PNG', margin, yPos, finalWidth, finalHeight);
                        yPos += finalHeight + 10;
                    } else if (item.type === 'text') {
                        // Midjourneyæç¤ºè©
                        pdf.setFontSize(12);
                        pdf.text('Midjourneyæç¤ºè©:', margin, yPos);
                        yPos += 10;
                        
                        pdf.setFontSize(10);
                        const splitText = pdf.splitTextToSize(item.content, pageWidth - 2 * margin);
                        pdf.text(splitText, margin, yPos);
                        yPos += splitText.length * 5 + 10;
                    } else {
                        // éŒ¯èª¤æƒ…æ³
                        pdf.setFontSize(10);
                        pdf.text('[åœ–ç‰‡è¼‰å…¥å¤±æ•—]', margin, yPos);
                        yPos += 20;
                    }
                    
                    // æ·»åŠ å ´æ™¯æè¿°
                    if (item.panel) {
                        pdf.setFontSize(12);
                        pdf.text('å ´æ™¯æè¿°:', margin, yPos);
                        yPos += 8;
                        
                        pdf.setFontSize(10);
                        const sceneText = pdf.splitTextToSize(item.panel.scene, pageWidth - 2 * margin);
                        pdf.text(sceneText, margin, yPos);
                        yPos += sceneText.length * 5;
                        
                        if (item.panel.dialogue) {
                            yPos += 5;
                            pdf.setFontSize(10);
                            pdf.text(`å°è©±: "${item.panel.dialogue}"`, margin, yPos);
                        }
                    }
                }
                
                // ä¿å­˜PDF
                const fileName = `mythology-comic-${Date.now()}.pdf`;
                pdf.save(fileName);
                
                showNotification('PDFå°å‡ºæˆåŠŸï¼', 'success');
                
            } catch (error) {
                console.error('PDFå°å‡ºå¤±æ•—:', error);
                alert('PDFå°å‡ºå¤±æ•—: ' + error.message);
            }
        }
        
        function shareComic() {
            const story = document.getElementById('storyInput').value;
            const storyTitle = story.substring(0, 50) + (story.length > 50 ? '...' : '');
            const shareText = `æˆ‘ç”¨AIå‰µä½œäº†ä¸€éƒ¨ç¥è©±æ¼«ç•«: ${storyTitle}`;
            
            if (navigator.share && /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                // ç§»å‹•ç«¯ä½¿ç”¨Web Share API
                navigator.share({
                    title: 'AIç¥è©±æ¼«ç•«ä½œå“',
                    text: shareText,
                    url: window.location.href
                }).then(() => {
                    showNotification('åˆ†äº«æˆåŠŸï¼', 'success');
                }).catch((error) => {
                    console.log('åˆ†äº«å–æ¶ˆ:', error);
                });
            } else {
                // æ¡Œé¢ç«¯è¤‡è£½åˆ°å‰ªè²¼æ¿
                navigator.clipboard.writeText(shareText + '\nç”Ÿæˆç¶²å€: ' + window.location.href).then(() => {
                    showNotification('åˆ†äº«æ–‡å­—å·²è¤‡è£½åˆ°å‰ªè²¼æ¿ï¼', 'success');
                }).catch(() => {
                    // é™ç´šæ–¹æ¡ˆ
                    const textArea = document.createElement('textarea');
                    textArea.value = shareText + '\nç”Ÿæˆç¶²å€: ' + window.location.href;
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showNotification('åˆ†äº«æ–‡å­—å·²è¤‡è£½åˆ°å‰ªè²¼æ¿ï¼', 'success');
                    } catch (err) {
                        alert('è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¤‡è£½: ' + shareText);
                    }
                    document.body.removeChild(textArea);
                });
            }
        }
        
        function showNotification(message, type = 'info') {
            // å‰µå»ºé€šçŸ¥å…ƒç´ 
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196f3'};
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                max-width: 300px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // é¡¯ç¤ºå‹•ç•«
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 10);
            
            // è‡ªå‹•æ¶ˆå¤±
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            loadExample('kuafu');
        });
    </script>
</body>
</html>