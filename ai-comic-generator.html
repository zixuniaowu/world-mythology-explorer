<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI神話漫畫生成系統 - 圖像故事創作平台</title>
    
    <!-- 外部庫 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 25px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-container {
            flex: 1;
            display: flex;
            max-width: 1600px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
            gap: 20px;
        }

        .input-panel {
            width: 400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .panel-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #ffd700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .story-textarea {
            width: 100%;
            height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            padding: 15px;
            font-size: 1em;
            line-height: 1.6;
            resize: vertical;
            font-family: inherit;
        }

        .story-textarea::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .example-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .example-btn {
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .example-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: #ffd700;
        }

        .config-group {
            margin-bottom: 15px;
        }

        .config-label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.95em;
            color: #ccc;
        }

        .config-select, .config-input {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-family: inherit;
        }

        .config-select option {
            background: #333;
            color: white;
        }

        .generate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #ffd700 0%, #ffb347 100%);
            border: none;
            border-radius: 10px;
            color: #333;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }

        .generate-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
        }

        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .comic-area {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            overflow-y: auto;
        }

        .comic-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .comic-title {
            font-size: 1.8em;
            color: #ffd700;
        }

        .view-controls {
            display: flex;
            gap: 10px;
        }

        .view-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .view-btn.active {
            background: #ffd700;
            color: #333;
            border-color: #ffd700;
        }

        .comic-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            padding: 20px;
            background: white;
            border-radius: 10px;
        }

        .comic-panel {
            background: white;
            border: 3px solid #333;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .panel-number {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #ffd700;
            color: #333;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 0.9em;
            z-index: 10;
        }

        .panel-image {
            width: 100%;
            height: 250px;
            background: linear-gradient(135deg, #e0e0e0, #f5f5f5);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .panel-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .panel-placeholder {
            text-align: center;
            color: #999;
            padding: 20px;
        }

        .panel-text {
            padding: 15px;
            background: white;
            color: #333;
            font-size: 0.95em;
            line-height: 1.5;
            border-top: 2px solid #f0f0f0;
        }

        .speech-bubble {
            background: white;
            border: 2px solid #333;
            border-radius: 15px;
            padding: 10px;
            margin: 10px;
            position: relative;
            color: #333;
            font-weight: bold;
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 30px;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid #333;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            text-align: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 215, 0, 0.3);
            border-top-color: #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.2em;
            color: #ffd700;
            margin-bottom: 10px;
        }

        .loading-progress {
            font-size: 0.9em;
            color: #ccc;
        }

        .storyboard-view {
            display: none;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .storyboard-item {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            align-items: center;
        }

        .storyboard-number {
            font-size: 2em;
            color: #ffd700;
            font-weight: bold;
            min-width: 50px;
        }

        .storyboard-content {
            flex: 1;
        }

        .storyboard-prompt {
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.9em;
            color: #4ecdc4;
        }

        .storyboard-description {
            line-height: 1.6;
        }

        .manga-layout {
            display: none;
            background: white;
            padding: 30px;
            border-radius: 10px;
        }

        .manga-page {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .manga-row {
            display: flex;
            min-height: 300px;
        }

        .manga-cell {
            flex: 1;
            border: 2px solid #333;
            position: relative;
            overflow: hidden;
        }

        .manga-cell.large {
            flex: 2;
        }

        .export-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .export-btn {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
            }
            
            .input-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🎨 AI神話漫畫生成系統</h1>
        <p class="subtitle">將神話故事轉化為精美的AI漫畫作品</p>
    </div>

    <div class="main-container">
        <div class="input-panel">
            <!-- 故事輸入 -->
            <div class="panel">
                <h3 class="panel-title">
                    <span>📖</span>
                    <span>輸入神話故事</span>
                </h3>
                
                <textarea class="story-textarea" id="storyInput" placeholder="輸入您的神話故事...

例如：
夸父是一位巨人，他看到太陽每天從東方升起西方落下，決心要追上太陽。他邁開巨大的步伐，翻越高山，跨過河流。渴了就喝乾黃河、渭水。最終力竭而亡，他的手杖化作桃林。"></textarea>

                <div class="example-buttons">
                    <button class="example-btn" onclick="loadExample('kuafu')">夸父逐日</button>
                    <button class="example-btn" onclick="loadExample('chang_e')">嫦娥奔月</button>
                    <button class="example-btn" onclick="loadExample('nezha')">哪吒鬧海</button>
                    <button class="example-btn" onclick="loadExample('susanoo')">須佐之男</button>
                </div>
            </div>

            <!-- AI設置 -->
            <div class="panel">
                <h3 class="panel-title">
                    <span>🎨</span>
                    <span>漫畫設置</span>
                </h3>

                <div class="config-group">
                    <label class="config-label">畫風選擇</label>
                    <select class="config-select" id="artStyle">
                        <option value="manga">日式漫畫風格</option>
                        <option value="chinese">中國水墨風</option>
                        <option value="realistic">寫實插畫風</option>
                        <option value="anime">動漫風格</option>
                        <option value="mythical">神話幻想風</option>
                        <option value="watercolor">水彩畫風</option>
                    </select>
                </div>

                <div class="config-group">
                    <label class="config-label">分鏡數量</label>
                    <select class="config-select" id="panelCount">
                        <option value="4">4格 (簡短)</option>
                        <option value="6" selected>6格 (標準)</option>
                        <option value="8">8格 (詳細)</option>
                        <option value="12">12格 (完整)</option>
                    </select>
                </div>

                <div class="config-group">
                    <label class="config-label">圖像生成方式</label>
                    <select class="config-select" id="imageGenerator">
                        <option value="demo">演示模式 (預覽)</option>
                        <option value="dalle3">DALL-E 3 (需API Key)</option>
                        <option value="stable-diffusion">Stable Diffusion</option>
                        <option value="midjourney">Midjourney提示詞</option>
                        <option value="local-sd">本地SD (需安裝)</option>
                    </select>
                </div>

                <div class="config-group" id="apiKeyGroup" style="display: none;">
                    <label class="config-label">API Key</label>
                    <input type="password" class="config-input" id="apiKey" placeholder="輸入您的API Key">
                </div>

                <button class="generate-btn" id="generateBtn" onclick="generateComic()">
                    🎬 生成漫畫
                </button>
            </div>

            <!-- 分鏡腳本 -->
            <div class="panel">
                <h3 class="panel-title">
                    <span>🎬</span>
                    <span>AI分鏡腳本</span>
                </h3>
                <div id="storyboardPreview" style="font-size: 0.9em; line-height: 1.6; color: #ccc;">
                    等待生成分鏡...
                </div>
            </div>
        </div>

        <!-- 漫畫展示區 -->
        <div class="comic-area">
            <div class="comic-header">
                <h2 class="comic-title">漫畫預覽</h2>
                <div class="view-controls">
                    <button class="view-btn active" onclick="switchView('grid')">網格</button>
                    <button class="view-btn" onclick="switchView('storyboard')">分鏡</button>
                    <button class="view-btn" onclick="switchView('manga')">漫畫</button>
                </div>
            </div>

            <!-- 網格視圖 -->
            <div class="comic-grid" id="comicGrid">
                <div class="comic-panel">
                    <div class="panel-image">
                        <div class="panel-placeholder">
                            <div style="font-size: 3em; margin-bottom: 10px;">🎨</div>
                            <div>等待生成漫畫...</div>
                            <div style="font-size: 0.9em; margin-top: 10px; opacity: 0.7;">
                                輸入故事並點擊"生成漫畫"開始
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 分鏡視圖 -->
            <div class="storyboard-view" id="storyboardView">
                <!-- 動態生成 -->
            </div>

            <!-- 漫畫版式 -->
            <div class="manga-layout" id="mangaLayout">
                <!-- 動態生成 -->
            </div>
        </div>
    </div>

    <!-- 加載覆蓋層 -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">AI正在創作您的神話漫畫...</div>
            <div class="loading-progress" id="loadingProgress">分析故事結構...</div>
        </div>
    </div>

    <!-- 導出控制 -->
    <div class="export-controls" id="exportControls" style="display: none;">
        <button class="export-btn" onclick="exportAsImage()">📥 導出圖片</button>
        <button class="export-btn" onclick="exportAsPDF()">📄 導出PDF</button>
        <button class="export-btn" onclick="shareComic()">🔗 分享</button>
    </div>

    <script>
        // ==================== 漫畫生成系統核心 ====================
        
        class ComicGenerator {
            constructor() {
                this.currentStory = '';
                this.storyboard = [];
                this.generatedImages = [];
                this.artStyle = 'manga';
                this.panelCount = 6;
                this.imageGenerator = 'demo';
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // 圖像生成方式切換
                document.getElementById('imageGenerator').addEventListener('change', (e) => {
                    const needsKey = ['dalle3', 'stable-diffusion'].includes(e.target.value);
                    document.getElementById('apiKeyGroup').style.display = needsKey ? 'block' : 'none';
                });
                
                // 其他設置
                document.getElementById('artStyle').addEventListener('change', (e) => {
                    this.artStyle = e.target.value;
                });
                
                document.getElementById('panelCount').addEventListener('change', (e) => {
                    this.panelCount = parseInt(e.target.value);
                });
            }
            
            async generateComic() {
                const storyText = document.getElementById('storyInput').value.trim();
                if (!storyText) {
                    alert('請輸入故事內容');
                    return;
                }
                
                this.currentStory = storyText;
                this.showLoading(true, '分析故事結構...');
                
                try {
                    // Step 1: 生成分鏡腳本
                    this.updateProgress('生成分鏡腳本...');
                    this.storyboard = await this.generateStoryboard(storyText);
                    this.displayStoryboard();
                    
                    // Step 2: 生成圖像提示詞
                    this.updateProgress('優化圖像提示詞...');
                    const prompts = await this.generateImagePrompts();
                    
                    // Step 3: 生成圖像
                    this.updateProgress('AI繪製圖像中...');
                    await this.generateImages(prompts);
                    
                    // Step 4: 組合成漫畫
                    this.updateProgress('組合漫畫頁面...');
                    this.assembleComic();
                    
                    // 完成
                    this.showLoading(false);
                    document.getElementById('exportControls').style.display = 'flex';
                    
                } catch (error) {
                    console.error('生成失敗:', error);
                    this.showLoading(false);
                    alert('生成過程出錯: ' + error.message);
                }
            }
            
            async generateStoryboard(story) {
                // 使用本地Qwen2生成分鏡
                if (window.ollama && this.imageGenerator !== 'demo') {
                    try {
                        const response = await fetch('http://localhost:11434/api/generate', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: 'qwen2:7b',
                                prompt: `請將以下神話故事分解為${this.panelCount}個漫畫分鏡，每個分鏡包含場景描述、人物動作、對話。

故事：${story}

請用JSON格式返回：
[
  {
    "panel": 1,
    "scene": "場景描述",
    "characters": "人物和動作",
    "dialogue": "對話或旁白",
    "mood": "情緒氛圍",
    "camera": "鏡頭角度"
  }
]`,
                                stream: false,
                                options: { temperature: 0.7 }
                            })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            const jsonMatch = data.response.match(/\[[\s\S]*?\]/);
                            if (jsonMatch) {
                                return JSON.parse(jsonMatch[0]);
                            }
                        }
                    } catch (e) {
                        console.warn('Qwen2分鏡生成失敗，使用智能分鏡');
                    }
                }
                
                // 智能分鏡算法
                return this.intelligentStoryboard(story);
            }
            
            intelligentStoryboard(story) {
                const sentences = story.split(/[。！？\n]/).filter(s => s.trim());
                const panelsPerSentence = Math.ceil(this.panelCount / sentences.length);
                const storyboard = [];
                
                sentences.forEach((sentence, idx) => {
                    // 分析句子內容
                    const hasAction = /跑|走|飛|戰|打|跳|追/.test(sentence);
                    const hasDialogue = /說|道|喊|叫/.test(sentence);
                    const hasEmotion = /怒|喜|悲|驚|恐/.test(sentence);
                    
                    // 根據內容決定分鏡數
                    const panels = hasAction ? Math.min(2, panelsPerSentence) : 1;
                    
                    for (let i = 0; i < panels; i++) {
                        storyboard.push({
                            panel: storyboard.length + 1,
                            scene: this.extractScene(sentence),
                            characters: this.extractCharacters(sentence),
                            dialogue: hasDialogue ? this.extractDialogue(sentence) : '',
                            mood: this.detectMood(sentence),
                            camera: hasAction ? (i === 0 ? 'wide' : 'close-up') : 'medium'
                        });
                    }
                });
                
                // 確保達到目標分鏡數
                while (storyboard.length < this.panelCount) {
                    const lastPanel = storyboard[storyboard.length - 1];
                    storyboard.push({
                        ...lastPanel,
                        panel: storyboard.length + 1,
                        camera: 'close-up'
                    });
                }
                
                return storyboard.slice(0, this.panelCount);
            }
            
            extractScene(text) {
                if (text.includes('山')) return '高聳的山脈，雲霧繚繞';
                if (text.includes('海')) return '波濤洶湧的大海';
                if (text.includes('天')) return '遼闊的天空';
                if (text.includes('森林')) return '茂密的原始森林';
                if (text.includes('宮')) return '華麗的宮殿';
                return '神話世界的場景';
            }
            
            extractCharacters(text) {
                const characters = [];
                if (text.includes('夸父')) characters.push('巨人夸父');
                if (text.includes('太陽')) characters.push('熾熱的太陽');
                if (text.includes('嫦娥')) characters.push('美麗的嫦娥');
                if (text.includes('哪吒')) characters.push('少年英雄哪吒');
                if (text.includes('龍')) characters.push('威嚴的龍');
                
                return characters.length > 0 ? characters.join('、') : '神話人物';
            }
            
            extractDialogue(text) {
                const dialogueMatch = text.match(/[「"](.*?)[」"]/);
                return dialogueMatch ? dialogueMatch[1] : '';
            }
            
            detectMood(text) {
                if (/激烈|憤怒|戰/.test(text)) return 'intense';
                if (/悲傷|哀|死/.test(text)) return 'sad';
                if (/喜|樂|笑/.test(text)) return 'happy';
                if (/恐|怕|驚/.test(text)) return 'fearful';
                return 'neutral';
            }
            
            async generateImagePrompts() {
                const stylePrompts = {
                    'manga': 'manga style, black and white with screentones, dynamic action lines',
                    'chinese': 'traditional Chinese ink painting style, watercolor, elegant brushstrokes',
                    'realistic': 'photorealistic illustration, detailed, cinematic lighting',
                    'anime': 'anime style, vibrant colors, expressive characters',
                    'mythical': 'fantasy art style, magical atmosphere, ethereal lighting',
                    'watercolor': 'watercolor painting, soft colors, artistic blur'
                };
                
                const baseStyle = stylePrompts[this.artStyle];
                
                return this.storyboard.map(panel => {
                    const prompt = `${baseStyle}, ${panel.scene}, ${panel.characters}, ${panel.mood} mood, ${panel.camera} shot, mythology illustration, high quality artwork`;
                    
                    // 添加負面提示詞
                    const negativePrompt = 'low quality, blurry, distorted, ugly, bad anatomy, text, watermark';
                    
                    return { 
                        positive: prompt, 
                        negative: negativePrompt,
                        panel: panel
                    };
                });
            }
            
            async generateImages(prompts) {
                this.generatedImages = [];
                
                for (let i = 0; i < prompts.length; i++) {
                    this.updateProgress(`生成第 ${i + 1}/${prompts.length} 幅圖像...`);
                    
                    switch (this.imageGenerator) {
                        case 'dalle3':
                            this.generatedImages.push(await this.generateWithDalle(prompts[i]));
                            break;
                        case 'stable-diffusion':
                            this.generatedImages.push(await this.generateWithSD(prompts[i]));
                            break;
                        case 'local-sd':
                            this.generatedImages.push(await this.generateWithLocalSD(prompts[i]));
                            break;
                        case 'midjourney':
                            this.generatedImages.push(this.generateMidjourneyPrompt(prompts[i]));
                            break;
                        default:
                            this.generatedImages.push(this.generateDemoImage(prompts[i], i));
                    }
                    
                    // 延遲避免API限制
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
            async generateWithDalle(prompt) {
                const apiKey = document.getElementById('apiKey').value;
                if (!apiKey) throw new Error('請提供OpenAI API Key');
                
                const response = await fetch('https://api.openai.com/v1/images/generations', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: "dall-e-3",
                        prompt: prompt.positive,
                        n: 1,
                        size: "1024x1024",
                        quality: "standard",
                        style: "vivid"
                    })
                });
                
                if (!response.ok) throw new Error('DALL-E 3 API錯誤');
                
                const data = await response.json();
                return data.data[0].url;
            }
            
            async generateWithSD(prompt) {
                // Stable Diffusion API (例如 Replicate)
                const apiKey = document.getElementById('apiKey').value;
                if (!apiKey) throw new Error('請提供Stable Diffusion API Key');
                
                // 這裡使用Replicate API作為示例
                const response = await fetch('https://api.replicate.com/v1/predictions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Token ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        version: "stability-ai/sdxl:latest",
                        input: {
                            prompt: prompt.positive,
                            negative_prompt: prompt.negative,
                            width: 1024,
                            height: 1024,
                            num_inference_steps: 30
                        }
                    })
                });
                
                if (!response.ok) throw new Error('Stable Diffusion API錯誤');
                
                const prediction = await response.json();
                // 等待生成完成
                return await this.waitForSDResult(prediction.id, apiKey);
            }
            
            async waitForSDResult(predictionId, apiKey) {
                // 輪詢檢查生成狀態
                for (let i = 0; i < 60; i++) {
                    const response = await fetch(`https://api.replicate.com/v1/predictions/${predictionId}`, {
                        headers: { 'Authorization': `Token ${apiKey}` }
                    });
                    
                    const result = await response.json();
                    if (result.status === 'succeeded') {
                        return result.output[0];
                    } else if (result.status === 'failed') {
                        throw new Error('圖像生成失敗');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                throw new Error('生成超時');
            }
            
            async generateWithLocalSD(prompt) {
                // 檢測本地Stable Diffusion WebUI可用性
                try {
                    // 首先檢查SD WebUI是否運行
                    const healthCheck = await fetch('http://localhost:7860/sdapi/v1/progress', {
                        method: 'GET',
                        timeout: 3000
                    });
                    
                    if (!healthCheck.ok) {
                        throw new Error('Stable Diffusion WebUI未運行');
                    }
                } catch (error) {
                    throw new Error(`無法連接到本地SD WebUI (http://localhost:7860)。請確保：
1. 已啟動 Stable Diffusion WebUI
2. 使用 --api 參數啟動
3. 關閉防火牆或添加例外
4. 檢查端口7860是否被佔用`);
                }
                
                // 增強的圖片生成參數
                const sdParams = {
                    prompt: this.enhanceSDPrompt(prompt.positive),
                    negative_prompt: prompt.negative + ', low quality, blurry, distorted, deformed, bad anatomy, mutilated, poorly drawn face',
                    steps: 25, // 適中的步數，平衡質量和速度
                    width: 512,
                    height: 512,
                    cfg_scale: 8, // 較高的引導尺度確保質量
                    sampler_name: "DPM++ 2M Karras",
                    seed: -1, // 隨機種子
                    restore_faces: true, // 修復面部
                    enable_hr: false, // 高解析度修復
                    hr_scale: 1.5,
                    hr_upscaler: "Latent",
                    hr_second_pass_steps: 15,
                    batch_size: 1,
                    n_iter: 1
                };
                
                // 根據藝術風格調整參數
                if (this.artStyle === 'manga') {
                    sdParams.width = 512;
                    sdParams.height = 768; // 漫畫格式更高
                } else if (this.artStyle === 'chinese') {
                    sdParams.cfg_scale = 7; // 中國水墨畫需要較低的引導
                    sdParams.steps = 30; // 更多步數獲得細膩效果
                }
                
                const response = await fetch('http://localhost:7860/sdapi/v1/txt2img', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(sdParams)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`SD WebUI錯誤 (${response.status}): ${errorText}`);
                }
                
                const data = await response.json();
                
                if (!data.images || data.images.length === 0) {
                    throw new Error('SD WebUI返回了空的圖像數組');
                }
                
                // 檢查生成的圖像是否有效
                const imageBase64 = data.images[0];
                if (!imageBase64 || imageBase64.length < 100) {
                    throw new Error('生成的圖像數據無效');
                }
                
                return 'data:image/png;base64,' + imageBase64;
            }
            
            enhanceSDPrompt(originalPrompt) {
                // 根據不同風格增強提示詞
                const styleEnhancements = {
                    'manga': 'manga style, anime, black and white, screentone, dynamic pose, expressive',
                    'chinese': 'traditional Chinese painting, ink wash, elegant brushstrokes, classical style',
                    'realistic': 'photorealistic, highly detailed, professional photography, cinematic lighting',
                    'anime': 'anime style, cel shading, vibrant colors, expressive eyes',
                    'mythical': 'fantasy art, mythological, magical atmosphere, epic composition',
                    'watercolor': 'watercolor painting, soft colors, artistic brush texture'
                };
                
                const enhancement = styleEnhancements[this.artStyle] || 'high quality, detailed';
                
                // 添加通用質量提升詞
                const qualityBoosts = 'masterpiece, best quality, ultra-detailed, sharp focus, professional artwork';
                
                return `${enhancement}, ${originalPrompt}, ${qualityBoosts}`;
            }
            
            async testLocalSDConnection() {
                try {
                    const response = await fetch('http://localhost:7860/sdapi/v1/options', {
                        method: 'GET',
                        timeout: 5000
                    });
                    
                    if (response.ok) {
                        const options = await response.json();
                        console.log('SD WebUI已連接，當前模型:', options.sd_model_checkpoint || '未知');
                        return { 
                            connected: true, 
                            model: options.sd_model_checkpoint,
                            version: options.version || '未知'
                        };
                    }
                } catch (error) {
                    console.warn('SD WebUI連接測試失敗:', error);
                }
                
                return { connected: false, error: '無法連接到SD WebUI' };
            }
            
            async getSDModels() {
                try {
                    const response = await fetch('http://localhost:7860/sdapi/v1/sd-models');
                    if (response.ok) {
                        const models = await response.json();
                        return models.map(m => ({
                            name: m.model_name,
                            title: m.title,
                            filename: m.filename
                        }));
                    }
                } catch (error) {
                    console.warn('獲取SD模型列表失敗:', error);
                }
                return [];
            }
            
            generateMidjourneyPrompt(prompt) {
                // 生成Midjourney提示詞供用戶複製
                const mjPrompt = `/imagine prompt: ${prompt.positive} --ar 1:1 --v 6 --style raw`;
                return {
                    type: 'midjourney',
                    prompt: mjPrompt,
                    instruction: '請複製此提示詞到Discord中的Midjourney Bot'
                };
            }
            
            generateDemoImage(prompt, index) {
                // 演示模式：使用Canvas生成更丰富的预览图
                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // 背景颜色和渐变
                const colors = [
                    ['#ff6b6b', '#ee5a6f'], // 红色渐变
                    ['#4ecdc4', '#44a08d'], // 青色渐变  
                    ['#45b7d1', '#96c93d'], // 蓝绿渐变
                    ['#96ceb4', '#ffecd2'], // 绿色渐变
                    ['#ffeaa7', '#fab2d0'], // 黄粉渐变
                    ['#dfe6e9', '#b2bec3']  // 灰色渐变
                ];
                
                const [color1, color2] = colors[index % colors.length];
                
                // 创建渐变背景
                const gradient = ctx.createLinearGradient(0, 0, 400, 400);
                gradient.addColorStop(0, color1);
                gradient.addColorStop(1, color2);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 400, 400);
                
                // 添加神话主题装饰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                this.drawMythologyPattern(ctx, prompt.panel, index);
                
                // 场景标题
                ctx.fillStyle = 'white';
                ctx.font = 'bold 28px Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`第 ${index + 1} 格`, 200, 60);
                
                // 场景描述 - 分行显示
                ctx.font = '16px Arial, sans-serif';
                const scene = prompt.panel.scene;
                const lines = this.wrapText(scene, 350, ctx);
                let y = 150;
                
                lines.forEach((line, idx) => {
                    if (idx < 4) { // 最多显示4行
                        ctx.fillText(line, 200, y + idx * 25);
                    }
                });
                
                // 人物信息
                ctx.font = '14px Arial, sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(`角色: ${prompt.panel.characters}`, 200, 280);
                
                // 氛围标识
                const moodColors = {
                    'intense': '🔥 激烈',
                    'sad': '😢 悲伤', 
                    'happy': '😊 欢乐',
                    'fearful': '😨 恐惧',
                    'neutral': '😐 平静'
                };
                
                const moodText = moodColors[prompt.panel.mood] || '😐 神秘';
                ctx.fillText(`氛围: ${moodText}`, 200, 310);
                
                // 镜头信息
                const cameraText = {
                    'wide': '广角镜头',
                    'close-up': '特写镜头', 
                    'medium': '中景镜头'
                };
                ctx.fillText(`镜头: ${cameraText[prompt.panel.camera] || '标准'}`, 200, 340);
                
                // 演示标识
                ctx.font = 'italic 12px Arial, sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillText('[AI演示预览 - 实际生成会更精美]', 200, 380);
                
                return canvas.toDataURL('image/png');
            }
            
            drawMythologyPattern(ctx, panel, index) {
                // 根据场景内容绘制不同的装饰图案
                const scene = panel.scene.toLowerCase();
                
                if (scene.includes('山') || scene.includes('mountain')) {
                    this.drawMountainPattern(ctx);
                } else if (scene.includes('海') || scene.includes('水') || scene.includes('water')) {
                    this.drawWavePattern(ctx);
                } else if (scene.includes('天') || scene.includes('cloud')) {
                    this.drawCloudPattern(ctx);
                } else if (scene.includes('龙') || scene.includes('dragon')) {
                    this.drawDragonPattern(ctx);
                } else {
                    this.drawStarPattern(ctx, index);
                }
            }
            
            drawMountainPattern(ctx) {
                // 绘制山形图案
                ctx.beginPath();
                ctx.moveTo(50, 350);
                ctx.lineTo(100, 250);
                ctx.lineTo(150, 280);
                ctx.lineTo(200, 200);
                ctx.lineTo(250, 260);
                ctx.lineTo(300, 220);
                ctx.lineTo(350, 350);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            drawWavePattern(ctx) {
                // 绘制波浪图案
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    const y = 320 + i * 20;
                    ctx.moveTo(0, y);
                    for (let x = 0; x <= 400; x += 20) {
                        ctx.quadraticCurveTo(x + 10, y - 10, x + 20, y);
                    }
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 - i * 0.1})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            drawCloudPattern(ctx) {
                // 绘制云朵图案
                for (let i = 0; i < 4; i++) {
                    const x = 50 + i * 80;
                    const y = 80 + Math.sin(i) * 20;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 15, 0, Math.PI * 2);
                    ctx.arc(x + 20, y, 20, 0, Math.PI * 2);
                    ctx.arc(x + 40, y, 15, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fill();
                }
            }
            
            drawDragonPattern(ctx) {
                // 绘制简化龙鳞图案
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const x = 50 + i * 40;
                        const y = 50 + j * 40;
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 8, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.1 + (i + j) * 0.01})`;
                        ctx.fill();
                    }
                }
            }
            
            drawStarPattern(ctx, seed) {
                // 绘制星星图案
                for (let i = 0; i < 20; i++) {
                    const x = (seed * 37 + i * 73) % 400;
                    const y = (seed * 23 + i * 91) % 400;
                    const size = 2 + (i % 3);
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + Math.random() * 0.4})`;
                    this.drawStar(ctx, x, y, size);
                }
            }
            
            drawStar(ctx, x, y, size) {
                ctx.save();
                ctx.translate(x, y);
                ctx.beginPath();
                ctx.moveTo(0, -size);
                for (let i = 0; i < 5; i++) {
                    ctx.rotate(Math.PI / 5);
                    ctx.lineTo(0, -size * 0.5);
                    ctx.rotate(Math.PI / 5);
                    ctx.lineTo(0, -size);
                }
                ctx.fill();
                ctx.restore();
            }
            
            wrapText(text, maxWidth, ctx) {
                const words = text.split('');
                const lines = [];
                let currentLine = '';
                
                for (let word of words) {
                    const testLine = currentLine + word;
                    const metrics = ctx.measureText(testLine);
                    
                    if (metrics.width > maxWidth && currentLine !== '') {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                }
                
                if (currentLine) {
                    lines.push(currentLine);
                }
                
                return lines;
            }
            
            displayStoryboard() {
                const preview = document.getElementById('storyboardPreview');
                preview.innerHTML = this.storyboard.map((panel, idx) => `
                    <div style="margin-bottom: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px;">
                        <strong style="color: #ffd700;">第${panel.panel}格:</strong> ${panel.scene}<br>
                        <small style="opacity: 0.8;">人物: ${panel.characters} | 氛圍: ${panel.mood}</small>
                    </div>
                `).join('');
            }
            
            assembleComic() {
                // 網格視圖
                const grid = document.getElementById('comicGrid');
                grid.innerHTML = this.generatedImages.map((img, idx) => {
                    const panel = this.storyboard[idx];
                    
                    if (typeof img === 'object' && img.type === 'midjourney') {
                        return `
                            <div class="comic-panel">
                                <div class="panel-number">${idx + 1}</div>
                                <div class="panel-image">
                                    <div class="panel-placeholder">
                                        <div style="padding: 20px;">
                                            <div style="font-size: 1.5em; margin-bottom: 10px;">Midjourney提示詞</div>
                                            <div style="font-family: monospace; font-size: 0.8em; background: rgba(0,0,0,0.1); padding: 10px; border-radius: 5px;">
                                                ${img.prompt}
                                            </div>
                                            <div style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
                                                ${img.instruction}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="panel-text">${panel.scene}</div>
                            </div>
                        `;
                    }
                    
                    return `
                        <div class="comic-panel">
                            <div class="panel-number">${idx + 1}</div>
                            <div class="panel-image">
                                <img src="${img}" alt="場景${idx + 1}">
                            </div>
                            <div class="panel-text">
                                ${panel.dialogue ? `<div class="speech-bubble">${panel.dialogue}</div>` : ''}
                                ${panel.scene}
                            </div>
                        </div>
                    `;
                }).join('');
                
                // 分鏡視圖
                const storyboard = document.getElementById('storyboardView');
                storyboard.innerHTML = this.storyboard.map((panel, idx) => `
                    <div class="storyboard-item">
                        <div class="storyboard-number">${panel.panel}</div>
                        <div class="storyboard-content">
                            <div class="storyboard-prompt">
                                鏡頭: ${panel.camera} | 氛圍: ${panel.mood}
                            </div>
                            <div class="storyboard-description">
                                <strong>場景:</strong> ${panel.scene}<br>
                                <strong>人物:</strong> ${panel.characters}<br>
                                ${panel.dialogue ? `<strong>對話:</strong> "${panel.dialogue}"` : ''}
                            </div>
                        </div>
                    </div>
                `).join('');
                
                // 漫畫版式
                this.generateMangaLayout();
            }
            
            generateMangaLayout() {
                const manga = document.getElementById('mangaLayout');
                const panels = this.generatedImages.map((img, idx) => ({
                    image: img,
                    panel: this.storyboard[idx],
                    index: idx
                }));
                
                // 智能漫畫排版算法
                const rows = this.calculateMangaRows(panels.length);
                let panelIndex = 0;
                
                manga.innerHTML = rows.map(rowConfig => {
                    const rowPanels = panels.slice(panelIndex, panelIndex + rowConfig.panels);
                    panelIndex += rowConfig.panels;
                    
                    return `
                        <div class="manga-row" style="height: ${rowConfig.height}px;">
                            ${rowPanels.map((item, cellIdx) => {
                                const isLarge = rowConfig.layout[cellIdx] === 'large';
                                return this.createMangaCell(item, isLarge);
                            }).join('')}
                        </div>
                    `;
                }).join('');
            }
            
            calculateMangaRows(totalPanels) {
                // 智能分配漫畫頁面布局
                const layouts = [
                    { panels: 1, height: 400, layout: ['large'] },
                    { panels: 2, height: 300, layout: ['medium', 'medium'] },
                    { panels: 2, height: 350, layout: ['large', 'small'] },
                    { panels: 3, height: 250, layout: ['small', 'small', 'small'] },
                    { panels: 3, height: 300, layout: ['large', 'small', 'small'] }
                ];
                
                const rows = [];
                let remaining = totalPanels;
                
                while (remaining > 0) {
                    let bestLayout;
                    
                    if (remaining === 1) {
                        bestLayout = layouts[0]; // 單格大圖
                    } else if (remaining === 2) {
                        bestLayout = Math.random() > 0.5 ? layouts[1] : layouts[2]; // 隨機選擇雙格布局
                    } else if (remaining >= 3) {
                        // 根據情節選擇布局
                        const currentPanelIndex = totalPanels - remaining;
                        const currentPanel = this.storyboard[currentPanelIndex];
                        
                        if (currentPanel && currentPanel.mood === 'intense') {
                            bestLayout = layouts[2]; // 激烈場面用大格
                        } else {
                            bestLayout = layouts[Math.floor(Math.random() * 3) + 2]; // 隨機選擇
                        }
                    }
                    
                    rows.push(bestLayout);
                    remaining -= bestLayout.panels;
                }
                
                return rows;
            }
            
            createMangaCell(item, isLarge = false) {
                const { image, panel, index } = item;
                const sizeClass = isLarge ? 'manga-cell large' : 'manga-cell';
                
                if (typeof image === 'object' && image.type === 'midjourney') {
                    return `
                        <div class="${sizeClass}">
                            <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px;">
                                格子 ${index + 1}
                            </div>
                            <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px 10px 10px; color: white;">
                                <div style="font-size: 0.8em; margin-bottom: 5px;">Midjourney提示詞:</div>
                                <div style="font-family: monospace; font-size: 0.7em;">${image.prompt}</div>
                            </div>
                        </div>
                    `;
                }
                
                return `
                    <div class="${sizeClass}" style="background-image: url('${image}'); background-size: cover; background-position: center;">
                        <div style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px;">
                            ${index + 1}
                        </div>
                        
                        ${panel.dialogue ? `
                            <div style="position: absolute; top: 20px; right: 20px; background: white; border: 2px solid #333; border-radius: 15px; padding: 8px 12px; max-width: 120px; font-size: 0.8em; color: #333;">
                                <div style="position: absolute; bottom: -8px; left: 20px; width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 8px solid white;"></div>
                                ${panel.dialogue}
                            </div>
                        ` : ''}
                        
                        ${panel.mood === 'intense' ? `
                            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: radial-gradient(circle, transparent 60%, rgba(255,0,0,0.1) 100%); pointer-events: none;"></div>
                        ` : ''}
                        
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 20px 10px 10px; color: white;">
                            <div style="font-size: 0.8em; opacity: 0.9;">${panel.scene}</div>
                        </div>
                    </div>
                `;
            }
            
            showLoading(show, message = '') {
                const overlay = document.getElementById('loadingOverlay');
                overlay.classList.toggle('active', show);
                if (message) {
                    document.getElementById('loadingProgress').textContent = message;
                }
            }
            
            updateProgress(message) {
                document.getElementById('loadingProgress').textContent = message;
            }
        }
        
        // ==================== 輔助函數 ====================
        
        const comicGenerator = new ComicGenerator();
        
        function generateComic() {
            comicGenerator.generateComic();
        }
        
        function loadExample(type) {
            const examples = {
                'kuafu': `夸父是遠古時代的巨人，他看到太陽每天從東方升起，西方落下，給大地帶來黑暗，決心要追上太陽，讓光明永駐人間。
他邁開巨大的步伐開始奔跑，一步跨過一座山，兩步越過一條河。他追著太陽跑了很久，越來越近了。
可是他太渴了，便俯身喝乾了黃河水，又喝乾了渭水，還是不解渴。他想去喝大澤的水，但還沒走到，就渴死在路上。
夸父死後，他的身軀化作了大山，手杖變成了一片桃林，為後來的人們提供甘甜的果實和陰涼。`,
                
                'chang_e': `后羿射下九個太陽後，西王母賜給他一包不死藥。后羿捨不得撇下妻子嫦娥，就把藥交給她保管。
一天，后羿外出狩獵，嫦娥獨自在家。她想起不死藥的事，忍不住打開來看。
藥的香味撲鼻而來，嫦娥忍不住吃了下去。頓時，她感到身體變輕，不由自主地飄了起來。
她飛出窗外，越飛越高，一直飛到了月宮。從此，嫦娥獨自住在清冷的月宮中，只有玉兔相伴。每當月圓之夜，她都會想念人間的丈夫。`,
                
                'nezha': `哪吒七歲時在東海邊洗澡，他把混天綾放在水裡搖晃，整個大海都震動起來，龍宮也搖晃不止。
龍王派三太子敖丙前來查看。敖丙看見是個小孩在搗亂，非常生氣，舉槍就刺。
哪吒機靈地躲開，用混天綾纏住敖丙的槍，又用乾坤圈打中敖丙的頭。敖丙現出龍形想要反擊。
哪吒毫不畏懼，跳到龍身上，一拳打死了敖丙，還抽了他的龍筋。龍王知道後大怒，要水淹陳塘關。`,
                
                'susanoo': `素戔嗚尊因為作惡被逐出高天原，來到人間。他聽說有個八岐大蛇每年要吃一個少女，今年輪到美麗的奇稻田姬。
素戔嗚尊決定除掉大蛇。他讓人準備了八桶烈酒，放在八個門口。
八岐大蛇來了，它有八個頭八條尾，身體龐大如山。看到美酒，八個頭都伸過去喝，很快就醉倒了。
素戔嗚尊拔出十拳劍，將大蛇的頭一個個砍下，又斬斷了它的尾巴。在蛇尾中，他發現了傳說中的草薙劍。`
            };
            
            document.getElementById('storyInput').value = examples[type] || '';
        }
        
        function switchView(view) {
            // 切換視圖
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            document.getElementById('comicGrid').style.display = view === 'grid' ? 'grid' : 'none';
            document.getElementById('storyboardView').style.display = view === 'storyboard' ? 'block' : 'none';
            document.getElementById('mangaLayout').style.display = view === 'manga' ? 'block' : 'none';
        }
        
        async function exportAsImage() {
            try {
                const activeView = document.querySelector('.view-btn.active').textContent;
                let targetElement;
                
                if (activeView === '網格') {
                    targetElement = document.getElementById('comicGrid');
                } else if (activeView === '分鏡') {
                    targetElement = document.getElementById('storyboardView');
                } else {
                    targetElement = document.getElementById('mangaLayout');
                }
                
                if (!targetElement || targetElement.children.length === 0) {
                    alert('請先生成漫畫內容');
                    return;
                }
                
                // 使用html2canvas導出圖片
                const canvas = await html2canvas(targetElement, {
                    backgroundColor: '#ffffff',
                    scale: 2, // 提高解析度
                    useCORS: true,
                    allowTaint: true,
                    imageTimeout: 0,
                    logging: false
                });
                
                // 創建下載連結
                const link = document.createElement('a');
                link.download = `mythology-comic-${activeView}-${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png');
                
                // 觸發下載
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // 顯示成功訊息
                showNotification('圖片導出成功！', 'success');
                
            } catch (error) {
                console.error('圖片導出失敗:', error);
                alert('圖片導出失敗，請檢查瀏覽器相容性');
            }
        }
        
        async function exportAsPDF() {
            try {
                // 檢查是否有內容
                if (!comicGenerator.generatedImages.length) {
                    alert('請先生成漫畫內容');
                    return;
                }
                
                // 創建新的jsPDF實例
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 10;
                
                // 添加標題頁
                pdf.setFontSize(24);
                pdf.text('AI神話漫畫作品', pageWidth / 2, 30, { align: 'center' });
                
                pdf.setFontSize(12);
                const story = document.getElementById('storyInput').value;
                const storyTitle = story.substring(0, 50) + (story.length > 50 ? '...' : '');
                pdf.text(storyTitle, pageWidth / 2, 50, { align: 'center' });
                
                pdf.setFontSize(10);
                pdf.text(`生成時間: ${new Date().toLocaleString('zh-TW')}`, pageWidth / 2, 70, { align: 'center' });
                
                // 等待所有圖片載入
                const imagePromises = comicGenerator.generatedImages.map((img, idx) => {
                    if (typeof img === 'object' && img.type === 'midjourney') {
                        return Promise.resolve({ type: 'text', content: img.prompt, panel: comicGenerator.storyboard[idx] });
                    }
                    
                    return new Promise((resolve, reject) => {
                        const image = new Image();
                        image.crossOrigin = 'anonymous';
                        image.onload = () => resolve({ type: 'image', element: image, panel: comicGenerator.storyboard[idx] });
                        image.onerror = () => resolve({ type: 'error', panel: comicGenerator.storyboard[idx] });
                        image.src = img;
                    });
                });
                
                const loadedImages = await Promise.all(imagePromises);
                
                // 為每個格子創建一頁
                for (let i = 0; i < loadedImages.length; i++) {
                    const item = loadedImages[i];
                    
                    if (i > 0) pdf.addPage();
                    
                    // 頁面標題
                    pdf.setFontSize(16);
                    pdf.text(`第 ${i + 1} 格`, margin, 20);
                    
                    let yPos = 40;
                    
                    if (item.type === 'image') {
                        // 添加圖片
                        const imgWidth = pageWidth - 2 * margin;
                        const imgHeight = (item.element.height / item.element.width) * imgWidth;
                        const maxHeight = pageHeight - 100;
                        
                        const finalHeight = Math.min(imgHeight, maxHeight);
                        const finalWidth = (finalHeight / imgHeight) * imgWidth;
                        
                        pdf.addImage(item.element, 'PNG', margin, yPos, finalWidth, finalHeight);
                        yPos += finalHeight + 10;
                    } else if (item.type === 'text') {
                        // Midjourney提示詞
                        pdf.setFontSize(12);
                        pdf.text('Midjourney提示詞:', margin, yPos);
                        yPos += 10;
                        
                        pdf.setFontSize(10);
                        const splitText = pdf.splitTextToSize(item.content, pageWidth - 2 * margin);
                        pdf.text(splitText, margin, yPos);
                        yPos += splitText.length * 5 + 10;
                    } else {
                        // 錯誤情況
                        pdf.setFontSize(10);
                        pdf.text('[圖片載入失敗]', margin, yPos);
                        yPos += 20;
                    }
                    
                    // 添加場景描述
                    if (item.panel) {
                        pdf.setFontSize(12);
                        pdf.text('場景描述:', margin, yPos);
                        yPos += 8;
                        
                        pdf.setFontSize(10);
                        const sceneText = pdf.splitTextToSize(item.panel.scene, pageWidth - 2 * margin);
                        pdf.text(sceneText, margin, yPos);
                        yPos += sceneText.length * 5;
                        
                        if (item.panel.dialogue) {
                            yPos += 5;
                            pdf.setFontSize(10);
                            pdf.text(`對話: "${item.panel.dialogue}"`, margin, yPos);
                        }
                    }
                }
                
                // 保存PDF
                const fileName = `mythology-comic-${Date.now()}.pdf`;
                pdf.save(fileName);
                
                showNotification('PDF導出成功！', 'success');
                
            } catch (error) {
                console.error('PDF導出失敗:', error);
                alert('PDF導出失敗: ' + error.message);
            }
        }
        
        function shareComic() {
            const story = document.getElementById('storyInput').value;
            const storyTitle = story.substring(0, 50) + (story.length > 50 ? '...' : '');
            const shareText = `我用AI創作了一部神話漫畫: ${storyTitle}`;
            
            if (navigator.share && /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                // 移動端使用Web Share API
                navigator.share({
                    title: 'AI神話漫畫作品',
                    text: shareText,
                    url: window.location.href
                }).then(() => {
                    showNotification('分享成功！', 'success');
                }).catch((error) => {
                    console.log('分享取消:', error);
                });
            } else {
                // 桌面端複製到剪貼板
                navigator.clipboard.writeText(shareText + '\n生成網址: ' + window.location.href).then(() => {
                    showNotification('分享文字已複製到剪貼板！', 'success');
                }).catch(() => {
                    // 降級方案
                    const textArea = document.createElement('textarea');
                    textArea.value = shareText + '\n生成網址: ' + window.location.href;
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showNotification('分享文字已複製到剪貼板！', 'success');
                    } catch (err) {
                        alert('複製失敗，請手動複製: ' + shareText);
                    }
                    document.body.removeChild(textArea);
                });
            }
        }
        
        function showNotification(message, type = 'info') {
            // 創建通知元素
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196f3'};
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                max-width: 300px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // 顯示動畫
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 10);
            
            // 自動消失
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
        
        // 初始化
        document.addEventListener('DOMContentLoaded', () => {
            loadExample('kuafu');
        });
    </script>
</body>
</html>