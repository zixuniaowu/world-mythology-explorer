<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>テキストアニメーション生成システム - 神話物語の自動アニメ化</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-container {
            flex: 1;
            display: flex;
            max-width: 1600px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
            gap: 20px;
        }

        .input-section {
            width: 400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .story-input {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .section-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #ffd700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .story-textarea {
            width: 100%;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            padding: 15px;
            font-size: 1em;
            line-height: 1.6;
            resize: vertical;
            font-family: inherit;
        }

        .story-textarea::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .story-textarea:focus {
            outline: none;
            border-color: #ffd700;
            background: rgba(255, 255, 255, 0.15);
        }

        .template-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .template-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .template-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: #ffd700;
            transform: translateY(-2px);
        }

        .generate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #ffd700 0%, #ffb347 100%);
            border: none;
            border-radius: 10px;
            color: #333;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
        }

        .analysis-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .analysis-section {
            margin-bottom: 20px;
        }

        .analysis-section h4 {
            color: #4ade80;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag {
            padding: 4px 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            font-size: 0.9em;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .tag.character { border-color: #ff6b6b; color: #ff6b6b; }
        .tag.action { border-color: #4ecdc4; color: #4ecdc4; }
        .tag.scene { border-color: #ffe66d; color: #ffe66d; }
        .tag.prop { border-color: #a8e6cf; color: #a8e6cf; }

        .timeline {
            margin-top: 15px;
        }

        .timeline-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
        }

        .timeline-number {
            background: #4ecdc4;
            color: #333;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
            font-weight: bold;
            margin-right: 15px;
        }

        .animation-canvas {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .canvas-title {
            font-size: 1.5em;
            color: #ffd700;
        }

        .playback-controls {
            display: flex;
            gap: 10px;
        }

        .control-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: #ffd700;
        }

        .control-btn.active {
            background: #ffd700;
            color: #333;
            border-color: #ffd700;
        }

        canvas {
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 50%, #F0E68C 100%);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .narration-box {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border-left: 4px solid #ffd700;
        }

        .narration-text {
            font-size: 1.1em;
            line-height: 1.6;
            color: #f0f0f0;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700 0%, #ffb347 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .settings-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #ffd700;
            border-radius: 50%;
            cursor: pointer;
        }

        .demo-examples {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .example-item {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid #4ecdc4;
        }

        .example-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .example-title {
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }

        .example-desc {
            font-size: 0.9em;
            opacity: 0.8;
            line-height: 1.4;
        }

        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
            }
            
            .input-section {
                width: 100%;
            }
        }

        .loading {
            display: none;
            text-align: center;
            color: #ffd700;
            margin: 20px 0;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            border-top-color: #ffd700;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🎭 テキストアニメーション生成システム</h1>
        <p>文字で神話物語を描き、火柴人アニメーションで表現する</p>
    </div>

    <div class="main-container">
        <div class="input-section">
            <!-- 故事輸入 -->
            <div class="story-input">
                <h3 class="section-title">
                    <span>📝</span>
                    <span>物語を入力</span>
                </h3>
                <textarea class="story-textarea" id="storyInput" placeholder="物語を入力してください...

例:
夸父は太陽を追いかけて走る。山を越え、川を渡り、ついに疲れ果てて倒れる。

哪吒は海辺で遊んでいる。混天綾を振ると海が揺れる。龍王の息子が現れ、二人は激しく戦う。

素戔嗚尊は八岐大蛇と対峙する。剣を抜いて勇敢に立ち向かう。"></textarea>

                <div class="template-buttons">
                    <button class="template-btn" onclick="loadTemplate('kuafu')">夸父逐日</button>
                    <button class="template-btn" onclick="loadTemplate('nezha')">哪吒鬧海</button>
                    <button class="template-btn" onclick="loadTemplate('susanoo')">素戔嗚尊</button>
                    <button class="template-btn" onclick="loadTemplate('chang_e')">嫦娥奔月</button>
                </div>

                <button class="generate-btn" onclick="generateAnimation()">
                    🎬 アニメーション生成
                </button>

                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <span>アニメーション生成中...</span>
                </div>
            </div>

            <!-- 解析結果 -->
            <div class="analysis-panel">
                <h3 class="section-title">
                    <span>🔍</span>
                    <span>解析結果</span>
                </h3>

                <div class="analysis-section">
                    <h4>検出された要素:</h4>
                    <div class="tag-list" id="detectedElements">
                        <!-- 動的に生成される -->
                    </div>
                </div>

                <div class="analysis-section">
                    <h4>アニメーションタイムライン:</h4>
                    <div class="timeline" id="timeline">
                        <!-- 動的に生成される -->
                    </div>
                </div>
            </div>

            <!-- 設定 -->
            <div class="settings-panel">
                <h3 class="section-title">
                    <span>⚙️</span>
                    <span>アニメーション設定</span>
                </h3>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>再生速度</span>
                        <span id="speedValue">1.0x</span>
                    </div>
                    <input type="range" class="slider" id="speedSlider" 
                           min="0.5" max="3" step="0.1" value="1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>表現度</span>
                        <span id="expressionValue">100%</span>
                    </div>
                    <input type="range" class="slider" id="expressionSlider" 
                           min="50" max="150" step="10" value="100">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>カメラ距離</span>
                        <span id="zoomValue">1.0x</span>
                    </div>
                    <input type="range" class="slider" id="zoomSlider" 
                           min="0.5" max="2" step="0.1" value="1">
                </div>
            </div>

            <!-- 範例 -->
            <div class="demo-examples">
                <h3 class="section-title">
                    <span>💡</span>
                    <span>参考例文</span>
                </h3>

                <div class="example-item" onclick="loadExample(this)">
                    <div class="example-title">夸父逐日</div>
                    <div class="example-desc">夸父は太陽を追いかけて大地を駆け抜け、最後に桃の森になる感動的な物語</div>
                </div>

                <div class="example-item" onclick="loadExample(this)">
                    <div class="example-title">八岐大蛇退治</div>
                    <div class="example-desc">素戔嗚尊が巨大な八つ頭の蛇を退治し、草薙剣を手に入れる英雄譚</div>
                </div>

                <div class="example-item" onclick="loadExample(this)">
                    <div class="example-title">精衛填海</div>
                    <div class="example-desc">小鳥の精衛が海を埋めようと小石を運び続ける不屈の精神の物語</div>
                </div>
            </div>
        </div>

        <div class="animation-canvas">
            <div class="canvas-header">
                <h3 class="canvas-title">🎬 アニメーションステージ</h3>
                <div class="playback-controls">
                    <button class="control-btn" id="playBtn" onclick="togglePlayback()">
                        ▶ 再生
                    </button>
                    <button class="control-btn" onclick="restartAnimation()">
                        ⏮ 最初から
                    </button>
                    <button class="control-btn" onclick="exportAnimation()">
                        💾 保存
                    </button>
                </div>
            </div>

            <canvas id="animationCanvas"></canvas>

            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div class="narration-box">
                <div class="narration-text" id="narrationText">
                    物語を入力してアニメーションを生成してください
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== 文本解析引擎 ====================
        
        class TextAnalyzer {
            constructor() {
                this.setupDictionaries();
            }
            
            setupDictionaries() {
                // 角色詞典
                this.characters = {
                    '夸父': { type: 'giant', color: '#ff6b6b', scale: 1.3 },
                    '哪吒': { type: 'child_god', color: '#ffd700', scale: 0.8 },
                    '敖丙': { type: 'dragon_prince', color: '#4169e1', scale: 1.1 },
                    '素戔嗚尊': { type: 'storm_god', color: '#8b00ff', scale: 1.2 },
                    '八岐大蛇': { type: 'serpent', color: '#228b22', scale: 2.0 },
                    '嫦娥': { type: 'moon_goddess', color: '#c0c0c0', scale: 0.9 },
                    '后羿': { type: 'archer', color: '#8b4513', scale: 1.1 },
                    '精衛': { type: 'bird', color: '#4ecdc4', scale: 0.5 },
                    '盤古': { type: 'creator', color: '#2f4f4f', scale: 1.5 }
                };
                
                // 動作詞典
                this.actions = {
                    '走る': { animation: 'run', intensity: 1.0 },
                    '追う': { animation: 'chase', intensity: 1.2 },
                    '追いかける': { animation: 'chase', intensity: 1.2 },
                    '飛ぶ': { animation: 'fly', intensity: 0.8 },
                    '戦う': { animation: 'fight', intensity: 1.5 },
                    '攻撃': { animation: 'attack', intensity: 1.3 },
                    '防ぐ': { animation: 'defend', intensity: 0.7 },
                    '立つ': { animation: 'stand', intensity: 0.3 },
                    '座る': { animation: 'sit', intensity: 0.2 },
                    '倒れる': { animation: 'fall', intensity: 0.5 },
                    '踊る': { animation: 'dance', intensity: 0.6 },
                    '泳ぐ': { animation: 'swim', intensity: 0.8 },
                    '登る': { animation: 'climb', intensity: 1.1 },
                    '射る': { animation: 'shoot', intensity: 1.0 },
                    '振る': { animation: 'swing', intensity: 0.9 },
                    '抜く': { animation: 'draw', intensity: 0.8 },
                    '投げる': { animation: 'throw', intensity: 1.0 },
                    '運ぶ': { animation: 'carry', intensity: 0.7 }
                };
                
                // 場景詞典
                this.scenes = {
                    '山': { background: 'mountain', props: ['trees', 'rocks'] },
                    '海': { background: 'ocean', props: ['waves', 'clouds'] },
                    '天空': { background: 'sky', props: ['clouds', 'sun'] },
                    '森': { background: 'forest', props: ['trees', 'bushes'] },
                    '宮殿': { background: 'palace', props: ['pillars', 'throne'] },
                    '川': { background: 'river', props: ['water', 'stones'] },
                    '砂漠': { background: 'desert', props: ['dunes', 'sun'] },
                    '月': { background: 'moon', props: ['stars', 'craters'] },
                    '地底': { background: 'underground', props: ['rocks', 'gems'] },
                    '雲': { background: 'clouds', props: ['mist', 'wind'] }
                };
                
                // 道具詞典
                this.props = {
                    '太陽': { type: 'celestial', color: '#ffd700', size: 'large' },
                    '月': { type: 'celestial', color: '#c0c0c0', size: 'large' },
                    '剣': { type: 'weapon', color: '#c0c0c0', size: 'medium' },
                    '弓': { type: 'weapon', color: '#8b4513', size: 'medium' },
                    '混天綾': { type: 'magic_cloth', color: '#ff69b4', size: 'flowing' },
                    '乾坤圏': { type: 'magic_ring', color: '#ffd700', size: 'small' },
                    '石': { type: 'natural', color: '#808080', size: 'small' },
                    '木': { type: 'natural', color: '#228b22', size: 'large' },
                    '水': { type: 'natural', color: '#4682b4', size: 'flowing' },
                    '火': { type: 'natural', color: '#ff4500', size: 'dancing' }
                };
                
                // 情感詞典
                this.emotions = {
                    '怒り': { intensity: 1.5, color: '#ff0000' },
                    '悲しみ': { intensity: 0.5, color: '#4169e1' },
                    '喜び': { intensity: 1.2, color: '#ffd700' },
                    '恐怖': { intensity: 0.8, color: '#800080' },
                    '勇気': { intensity: 1.3, color: '#ff6347' },
                    '愛': { intensity: 0.9, color: '#ff69b4' },
                    '決意': { intensity: 1.1, color: '#2e8b57' }
                };
            }
            
            analyze(text) {
                const result = {
                    characters: [],
                    actions: [],
                    scenes: [],
                    props: [],
                    timeline: [],
                    rawText: text
                };
                
                // 分句處理
                const sentences = text.split(/[。．.!！?？\n]/).filter(s => s.trim());
                
                sentences.forEach((sentence, index) => {
                    const sceneData = this.analyzeSentence(sentence.trim(), index);
                    if (sceneData.hasContent) {
                        result.timeline.push(sceneData);
                    }
                });
                
                // 提取所有元素
                result.timeline.forEach(scene => {
                    scene.characters.forEach(char => {
                        if (!result.characters.find(c => c.name === char)) {
                            result.characters.push({ name: char, ...this.characters[char] });
                        }
                    });
                    
                    scene.actions.forEach(action => {
                        if (!result.actions.find(a => a.name === action)) {
                            result.actions.push({ name: action, ...this.actions[action] });
                        }
                    });
                    
                    scene.scenes.forEach(scene_name => {
                        if (!result.scenes.find(s => s.name === scene_name)) {
                            result.scenes.push({ name: scene_name, ...this.scenes[scene_name] });
                        }
                    });
                    
                    scene.props.forEach(prop => {
                        if (!result.props.find(p => p.name === prop)) {
                            result.props.push({ name: prop, ...this.props[prop] });
                        }
                    });
                });
                
                return result;
            }
            
            analyzeSentence(sentence, index) {
                const sceneData = {
                    id: index,
                    text: sentence,
                    characters: [],
                    actions: [],
                    scenes: [],
                    props: [],
                    duration: 3000, // 預設3秒
                    hasContent: false
                };
                
                // 檢測角色
                for (const character in this.characters) {
                    if (sentence.includes(character)) {
                        sceneData.characters.push(character);
                        sceneData.hasContent = true;
                    }
                }
                
                // 檢測動作
                for (const action in this.actions) {
                    if (sentence.includes(action)) {
                        sceneData.actions.push(action);
                        sceneData.hasContent = true;
                    }
                }
                
                // 檢測場景
                for (const scene in this.scenes) {
                    if (sentence.includes(scene)) {
                        sceneData.scenes.push(scene);
                        sceneData.hasContent = true;
                    }
                }
                
                // 檢測道具
                for (const prop in this.props) {
                    if (sentence.includes(prop)) {
                        sceneData.props.push(prop);
                        sceneData.hasContent = true;
                    }
                }
                
                // 根據動作調整持續時間
                sceneData.actions.forEach(action => {
                    const actionData = this.actions[action];
                    if (actionData) {
                        sceneData.duration = Math.max(sceneData.duration, actionData.intensity * 2000);
                    }
                });
                
                return sceneData;
            }
        }

        // ==================== 角色系統 ====================
        
        class Character {
            constructor(name, data, x = 0, y = 0) {
                this.name = name;
                this.type = data.type || 'human';
                this.color = data.color || '#333';
                this.scale = data.scale || 1.0;
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.currentAnimation = 'idle';
                this.animationTime = 0;
                this.props = [];
                
                // 動作狀態
                this.limbAngles = {
                    leftArm: 0,
                    rightArm: 0,
                    leftLeg: 0,
                    rightLeg: 0,
                    body: 0,
                    head: 0
                };
                
                this.setupAnimations();
            }
            
            setupAnimations() {
                this.animations = {
                    idle: {
                        duration: 2000,
                        keyframes: [
                            { time: 0, leftArm: 0.2, rightArm: -0.2, leftLeg: 0, rightLeg: 0, body: 0 },
                            { time: 1000, leftArm: 0.25, rightArm: -0.25, leftLeg: 0.05, rightLeg: -0.05, body: 0.02 },
                            { time: 2000, leftArm: 0.2, rightArm: -0.2, leftLeg: 0, rightLeg: 0, body: 0 }
                        ]
                    },
                    run: {
                        duration: 600,
                        keyframes: [
                            { time: 0, leftArm: 0.8, rightArm: -0.8, leftLeg: 0.6, rightLeg: -0.6, body: 0.1 },
                            { time: 300, leftArm: -0.8, rightArm: 0.8, leftLeg: -0.6, rightLeg: 0.6, body: 0.1 },
                            { time: 600, leftArm: 0.8, rightArm: -0.8, leftLeg: 0.6, rightLeg: -0.6, body: 0.1 }
                        ]
                    },
                    fight: {
                        duration: 800,
                        keyframes: [
                            { time: 0, leftArm: -0.5, rightArm: 1.2, leftLeg: 0.2, rightLeg: -0.2, body: -0.1 },
                            { time: 200, leftArm: -0.3, rightArm: 0.8, leftLeg: 0.3, rightLeg: -0.3, body: 0.2 },
                            { time: 400, leftArm: 0.5, rightArm: -1.0, leftLeg: -0.2, rightLeg: 0.2, body: -0.1 },
                            { time: 800, leftArm: -0.5, rightArm: 1.2, leftLeg: 0.2, rightLeg: -0.2, body: -0.1 }
                        ]
                    },
                    fly: {
                        duration: 1000,
                        keyframes: [
                            { time: 0, leftArm: -1.2, rightArm: -1.2, leftLeg: -0.3, rightLeg: -0.3, body: 0.1 },
                            { time: 500, leftArm: -0.8, rightArm: -0.8, leftLeg: -0.1, rightLeg: -0.1, body: 0.05 },
                            { time: 1000, leftArm: -1.2, rightArm: -1.2, leftLeg: -0.3, rightLeg: -0.3, body: 0.1 }
                        ]
                    },
                    fall: {
                        duration: 1500,
                        keyframes: [
                            { time: 0, leftArm: 0.2, rightArm: -0.2, leftLeg: 0, rightLeg: 0, body: 0 },
                            { time: 500, leftArm: 0.8, rightArm: 0.8, leftLeg: -0.2, rightLeg: -0.2, body: -0.2 },
                            { time: 1000, leftArm: 1.5, rightArm: 1.5, leftLeg: 0.5, rightLeg: 0.5, body: 1.5 },
                            { time: 1500, leftArm: 1.5, rightArm: 1.5, leftLeg: 0.5, rightLeg: 0.5, body: 1.5 }
                        ]
                    }
                };
            }
            
            playAnimation(animationName) {
                if (this.animations[animationName]) {
                    this.currentAnimation = animationName;
                    this.animationTime = 0;
                }
            }
            
            update(deltaTime) {
                const animation = this.animations[this.currentAnimation];
                if (!animation) return;
                
                this.animationTime = (this.animationTime + deltaTime) % animation.duration;
                
                // 找到當前關鍵幀
                const keyframes = animation.keyframes;
                let prevFrame = keyframes[0];
                let nextFrame = keyframes[1];
                
                for (let i = 0; i < keyframes.length - 1; i++) {
                    if (this.animationTime >= keyframes[i].time && 
                        this.animationTime <= keyframes[i + 1].time) {
                        prevFrame = keyframes[i];
                        nextFrame = keyframes[i + 1];
                        break;
                    }
                }
                
                // 插值計算
                const frameDuration = nextFrame.time - prevFrame.time;
                const progress = (this.animationTime - prevFrame.time) / frameDuration;
                
                this.limbAngles.leftArm = this.lerp(prevFrame.leftArm, nextFrame.leftArm, progress);
                this.limbAngles.rightArm = this.lerp(prevFrame.rightArm, nextFrame.rightArm, progress);
                this.limbAngles.leftLeg = this.lerp(prevFrame.leftLeg, nextFrame.leftLeg, progress);
                this.limbAngles.rightLeg = this.lerp(prevFrame.rightLeg, nextFrame.rightLeg, progress);
                this.limbAngles.body = this.lerp(prevFrame.body, nextFrame.body, progress);
                
                // 移動到目標位置
                this.x += (this.targetX - this.x) * 0.05;
                this.y += (this.targetY - this.y) * 0.05;
            }
            
            lerp(a, b, t) {
                return a + (b - a) * t;
            }
            
            moveTo(x, y) {
                this.targetX = x;
                this.targetY = y;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                ctx.rotate(this.limbAngles.body);
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                // 特殊類型渲染
                if (this.type === 'bird') {
                    this.drawBird(ctx);
                } else if (this.type === 'serpent') {
                    this.drawSerpent(ctx);
                } else {
                    this.drawHuman(ctx);
                }
                
                // 繪製道具
                this.props.forEach(prop => this.drawProp(ctx, prop));
                
                ctx.restore();
            }
            
            drawHuman(ctx) {
                // 頭部
                ctx.beginPath();
                ctx.arc(0, -60, 18, 0, Math.PI * 2);
                ctx.stroke();
                
                // 根據類型添加特殊特徵
                if (this.type === 'child_god') {
                    // 哪吒的蓮花裝飾
                    ctx.strokeStyle = '#ff69b4';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 6; i++) {
                        ctx.beginPath();
                        const angle = (Math.PI * 2 / 6) * i;
                        const x = Math.cos(angle) * 25;
                        const y = -60 + Math.sin(angle) * 25;
                        ctx.moveTo(0, -60);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    }
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 4;
                }
                
                // 身體
                ctx.beginPath();
                ctx.moveTo(0, -42);
                ctx.lineTo(0, 20);
                ctx.stroke();
                
                // 左臂
                ctx.save();
                ctx.translate(0, -20);
                ctx.rotate(this.limbAngles.leftArm);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-30, 20);
                ctx.stroke();
                ctx.restore();
                
                // 右臂
                ctx.save();
                ctx.translate(0, -20);
                ctx.rotate(this.limbAngles.rightArm);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(30, 20);
                ctx.stroke();
                ctx.restore();
                
                // 左腿
                ctx.save();
                ctx.translate(0, 20);
                ctx.rotate(this.limbAngles.leftLeg);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-20, 35);
                ctx.stroke();
                ctx.restore();
                
                // 右腿
                ctx.save();
                ctx.translate(0, 20);
                ctx.rotate(this.limbAngles.rightLeg);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(20, 35);
                ctx.stroke();
                ctx.restore();
            }
            
            drawBird(ctx) {
                // 鳥類的簡化繪製
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 翅膀
                const wingAngle = Math.sin(this.animationTime * 0.01) * 0.5;
                ctx.save();
                ctx.rotate(wingAngle);
                ctx.beginPath();
                ctx.ellipse(-12, -5, 10, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.rotate(-wingAngle);
                ctx.beginPath();
                ctx.ellipse(12, -5, 10, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            drawSerpent(ctx) {
                // 蛇的簡化繪製
                ctx.lineWidth = 8;
                const segments = 8;
                for (let i = 0; i < segments; i++) {
                    const x = i * 15;
                    const y = Math.sin(this.animationTime * 0.005 + i * 0.5) * 10;
                    
                    if (i === 0) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 多個頭部
                for (let head = 0; head < 8; head++) {
                    const headX = -20 + head * 15;
                    const headY = -20;
                    ctx.beginPath();
                    ctx.arc(headX, headY, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            drawProp(ctx, prop) {
                // 根據道具類型繪製
                ctx.save();
                ctx.strokeStyle = prop.color || '#666';
                ctx.fillStyle = prop.color || '#666';
                
                switch(prop.type) {
                    case 'weapon':
                        // 武器
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(20, -10);
                        ctx.lineTo(35, -25);
                        ctx.stroke();
                        break;
                    case 'magic_cloth':
                        // 魔法布匹
                        ctx.lineWidth = 3;
                        for (let i = 0; i < 50; i++) {
                            const x = 20 + i;
                            const y = -10 + Math.sin(this.animationTime * 0.01 + i * 0.2) * 5;
                            if (i === 0) {
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.stroke();
                        break;
                }
                
                ctx.restore();
            }
        }

        // ==================== 動畫管理器 ====================
        
        class StoryAnimationManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.characters = new Map();
                this.scenes = [];
                this.currentSceneIndex = 0;
                this.sceneTime = 0;
                this.isPlaying = false;
                this.speed = 1.0;
                this.expressionLevel = 1.0;
                this.zoomLevel = 1.0;
                
                this.setupCanvas();
            }
            
            setupCanvas() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = 500;
            }
            
            loadStory(analysisResult) {
                this.characters.clear();
                this.scenes = analysisResult.timeline;
                this.currentSceneIndex = 0;
                this.sceneTime = 0;
                
                // 創建角色
                analysisResult.characters.forEach((charData, index) => {
                    const x = (this.canvas.width / (analysisResult.characters.length + 1)) * (index + 1);
                    const y = this.canvas.height / 2 + 50;
                    const character = new Character(charData.name, charData, x, y);
                    this.characters.set(charData.name, character);
                });
                
                this.startScene(0);
            }
            
            startScene(sceneIndex) {
                if (sceneIndex >= this.scenes.length) {
                    this.currentSceneIndex = 0;
                    sceneIndex = 0;
                }
                
                this.currentSceneIndex = sceneIndex;
                this.sceneTime = 0;
                
                const scene = this.scenes[sceneIndex];
                if (!scene) return;
                
                // 為角色分配動畫和位置
                scene.characters.forEach((charName, index) => {
                    const character = this.characters.get(charName);
                    if (character) {
                        // 設置位置
                        const totalChars = scene.characters.length;
                        const x = (this.canvas.width / (totalChars + 1)) * (index + 1);
                        character.moveTo(x, character.y);
                        
                        // 設置動畫
                        if (scene.actions.length > 0) {
                            const action = scene.actions[0];
                            const animMapping = {
                                '走る': 'run',
                                '追う': 'run',
                                '追いかける': 'run',
                                '飛ぶ': 'fly',
                                '戦う': 'fight',
                                '攻撃': 'fight',
                                '防ぐ': 'idle',
                                '倒れる': 'fall',
                                '踊る': 'idle',
                                '振る': 'fight'
                            };
                            
                            character.playAnimation(animMapping[action] || 'idle');
                        } else {
                            character.playAnimation('idle');
                        }
                    }
                });
                
                // 更新UI
                document.getElementById('narrationText').textContent = scene.text;
                this.updateProgress();
            }
            
            update(deltaTime) {
                if (!this.isPlaying) return;
                
                const scene = this.scenes[this.currentSceneIndex];
                if (!scene) return;
                
                this.sceneTime += deltaTime * this.speed;
                
                // 更新所有角色
                this.characters.forEach(character => {
                    character.update(deltaTime * this.speed * this.expressionLevel);
                });
                
                // 檢查場景是否結束
                if (this.sceneTime >= scene.duration) {
                    this.startScene(this.currentSceneIndex + 1);
                }
                
                this.updateProgress();
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 繪製背景
                this.drawBackground();
                
                // 繪製角色
                this.ctx.save();
                this.ctx.scale(this.zoomLevel, this.zoomLevel);
                this.ctx.translate(
                    (this.canvas.width * (1 - this.zoomLevel)) / (2 * this.zoomLevel),
                    (this.canvas.height * (1 - this.zoomLevel)) / (2 * this.zoomLevel)
                );
                
                this.characters.forEach(character => {
                    character.draw(this.ctx);
                });
                
                this.ctx.restore();
                
                // 繪製特效
                this.drawEffects();
            }
            
            drawBackground() {
                const scene = this.scenes[this.currentSceneIndex];
                if (!scene) return;
                
                // 根據場景類型選擇背景
                const sceneType = scene.scenes[0];
                let gradient;
                
                switch(sceneType) {
                    case '山':
                        gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                        gradient.addColorStop(0, '#87CEEB');
                        gradient.addColorStop(1, '#228B22');
                        break;
                    case '海':
                        gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                        gradient.addColorStop(0, '#87CEEB');
                        gradient.addColorStop(1, '#4682B4');
                        break;
                    case '天空':
                        gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                        gradient.addColorStop(0, '#FFD700');
                        gradient.addColorStop(1, '#87CEEB');
                        break;
                    default:
                        gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                        gradient.addColorStop(0, '#98FB98');
                        gradient.addColorStop(1, '#90EE90');
                }
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 繪製地面
                this.ctx.fillStyle = '#8B4513';
                this.ctx.fillRect(0, this.canvas.height - 50, this.canvas.width, 50);
            }
            
            drawEffects() {
                const scene = this.scenes[this.currentSceneIndex];
                if (!scene) return;
                
                // 繪製道具
                scene.props.forEach(propName => {
                    this.drawSceneProp(propName);
                });
            }
            
            drawSceneProp(propName) {
                this.ctx.save();
                
                switch(propName) {
                    case '太陽':
                        this.ctx.fillStyle = '#FFD700';
                        this.ctx.beginPath();
                        this.ctx.arc(this.canvas.width - 100, 100, 40, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // 陽光線
                        this.ctx.strokeStyle = '#FFA500';
                        this.ctx.lineWidth = 3;
                        for (let i = 0; i < 12; i++) {
                            const angle = (Math.PI * 2 / 12) * i;
                            const x1 = (this.canvas.width - 100) + Math.cos(angle) * 50;
                            const y1 = 100 + Math.sin(angle) * 50;
                            const x2 = (this.canvas.width - 100) + Math.cos(angle) * 70;
                            const y2 = 100 + Math.sin(angle) * 70;
                            
                            this.ctx.beginPath();
                            this.ctx.moveTo(x1, y1);
                            this.ctx.lineTo(x2, y2);
                            this.ctx.stroke();
                        }
                        break;
                        
                    case '月':
                        this.ctx.fillStyle = '#C0C0C0';
                        this.ctx.beginPath();
                        this.ctx.arc(100, 100, 35, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // 月球表面
                        this.ctx.fillStyle = '#A9A9A9';
                        this.ctx.beginPath();
                        this.ctx.arc(110, 90, 5, 0, Math.PI * 2);
                        this.ctx.arc(90, 110, 7, 0, Math.PI * 2);
                        this.ctx.arc(105, 115, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                        break;
                }
                
                this.ctx.restore();
            }
            
            updateProgress() {
                const totalScenes = this.scenes.length;
                const currentProgress = this.currentSceneIndex / totalScenes;
                const sceneProgress = this.sceneTime / (this.scenes[this.currentSceneIndex]?.duration || 1000);
                const totalProgress = (currentProgress + sceneProgress / totalScenes) * 100;
                
                document.getElementById('progressFill').style.width = Math.min(totalProgress, 100) + '%';
            }
            
            play() {
                this.isPlaying = true;
                document.getElementById('playBtn').innerHTML = '⏸ 一時停止';
                document.getElementById('playBtn').classList.add('active');
            }
            
            pause() {
                this.isPlaying = false;
                document.getElementById('playBtn').innerHTML = '▶ 再生';
                document.getElementById('playBtn').classList.remove('active');
            }
            
            restart() {
                this.startScene(0);
                this.pause();
            }
            
            setSpeed(speed) {
                this.speed = speed;
            }
            
            setExpression(level) {
                this.expressionLevel = level;
            }
            
            setZoom(level) {
                this.zoomLevel = level;
            }
        }

        // ==================== 主程序初始化 ====================
        
        // 初始化系統
        const canvas = document.getElementById('animationCanvas');
        const textAnalyzer = new TextAnalyzer();
        const animationManager = new StoryAnimationManager(canvas);
        
        let currentAnalysis = null;
        
        // 預設故事模板
        const storyTemplates = {
            kuafu: `夸父は太陽を追いかけて走る。山を越え、川を渡り、大地を駆け抜ける。
ついに渇きに耐えきれず、黄河と渭水を飲み干す。
それでも足りず、北の大湖へ向かうが、ついに力尽きて倒れる。
夸父の杖は桃の森となり、永遠に旅人を潤す。`,
            
            nezha: `哪吒は海辺で混天綾を振って遊んでいる。海が激しく揺れ、龍宮まで震動が伝わる。
怒った龍王は息子の敖丙を派遣する。敖丙が現れ、哪吒を叱責する。
若い哪吒は怒り、二人は激しく戦う。乾坤圏が飛び交い、混天綾が舞う。
ついに哪吒が勝利し、敖丙の龍筋を抜き取る。`,
            
            susanoo: `素戔嗚尊は八岐大蛇の前に立ちはだかる。巨大な八つの頭が天を覆う。
勇敢に剣を抜き、大蛇に立ち向かう。激しい戦いが始まる。
酒で大蛇を酔わせ、隙を突いて尾を切り落とす。
尾の中から草薙剣を発見し、姉の天照大神に献上する。`,
            
            chang_e: `后羿は十個の太陽を弓で射落とし、不老不死の薬を手に入れる。
妻の嫦娥がその薬を見つけ、こっそりと飲んでしまう。
嫦娥の体が軽くなり、空へと舞い上がる。
ついに月の世界へと飛び立ち、永遠にそこで暮らすことになる。`
        };
        
        // イベントリスナー設定
        function setupEventListeners() {
            // 速度調整
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                const speed = parseFloat(e.target.value);
                animationManager.setSpeed(speed);
                document.getElementById('speedValue').textContent = speed + 'x';
            });
            
            // 表現度調整
            document.getElementById('expressionSlider').addEventListener('input', (e) => {
                const expression = parseFloat(e.target.value) / 100;
                animationManager.setExpression(expression);
                document.getElementById('expressionValue').textContent = e.target.value + '%';
            });
            
            // ズーム調整
            document.getElementById('zoomSlider').addEventListener('input', (e) => {
                const zoom = parseFloat(e.target.value);
                animationManager.setZoom(zoom);
                document.getElementById('zoomValue').textContent = zoom + 'x';
            });
            
            // Canvas リサイズ
            window.addEventListener('resize', () => {
                animationManager.setupCanvas();
            });
        }
        
        // テンプレート読み込み
        function loadTemplate(templateName) {
            const template = storyTemplates[templateName];
            if (template) {
                document.getElementById('storyInput').value = template;
            }
        }
        
        // サンプル読み込み
        function loadExample(element) {
            const title = element.querySelector('.example-title').textContent;
            const template = storyTemplates[Object.keys(storyTemplates).find(key => 
                storyTemplates[key].includes(title.split('').slice(0, 2).join(''))
            )];
            
            if (template) {
                document.getElementById('storyInput').value = template;
            }
        }
        
        // アニメーション生成
        function generateAnimation() {
            const storyText = document.getElementById('storyInput').value.trim();
            if (!storyText) {
                alert('物語を入力してください');
                return;
            }
            
            // ローディング表示
            document.getElementById('loading').classList.add('show');
            
            // 解析実行
            setTimeout(() => {
                currentAnalysis = textAnalyzer.analyze(storyText);
                displayAnalysis(currentAnalysis);
                animationManager.loadStory(currentAnalysis);
                
                document.getElementById('loading').classList.remove('show');
            }, 1000);
        }
        
        // 解析結果表示
        function displayAnalysis(analysis) {
            // 検出要素表示
            const elementsContainer = document.getElementById('detectedElements');
            elementsContainer.innerHTML = '';
            
            analysis.characters.forEach(char => {
                const tag = document.createElement('div');
                tag.className = 'tag character';
                tag.textContent = char.name;
                elementsContainer.appendChild(tag);
            });
            
            analysis.actions.forEach(action => {
                const tag = document.createElement('div');
                tag.className = 'tag action';
                tag.textContent = action.name;
                elementsContainer.appendChild(tag);
            });
            
            analysis.scenes.forEach(scene => {
                const tag = document.createElement('div');
                tag.className = 'tag scene';
                tag.textContent = scene.name;
                elementsContainer.appendChild(tag);
            });
            
            analysis.props.forEach(prop => {
                const tag = document.createElement('div');
                tag.className = 'tag prop';
                tag.textContent = prop.name;
                elementsContainer.appendChild(tag);
            });
            
            // タイムライン表示
            const timelineContainer = document.getElementById('timeline');
            timelineContainer.innerHTML = '';
            
            analysis.timeline.forEach((scene, index) => {
                const item = document.createElement('div');
                item.className = 'timeline-item';
                item.innerHTML = `
                    <div class="timeline-number">${index + 1}</div>
                    <div>${scene.text}</div>
                `;
                timelineContainer.appendChild(item);
            });
        }
        
        // 再生制御
        function togglePlayback() {
            if (animationManager.isPlaying) {
                animationManager.pause();
            } else {
                animationManager.play();
            }
        }
        
        function restartAnimation() {
            animationManager.restart();
        }
        
        function exportAnimation() {
            // 簡単な保存機能（実装は省略）
            alert('アニメーション保存機能は開発中です');
        }
        
        // アニメーションループ
        function animate() {
            animationManager.update(16); // 約60fps
            animationManager.render();
            requestAnimationFrame(animate);
        }
        
        // 初期化実行
        setupEventListeners();
        animate();
        
        // デモ用：自動的に最初のテンプレートを読み込み
        setTimeout(() => {
            loadTemplate('kuafu');
        }, 500);
    </script>
</body>
</html>