<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å—å±±çµŒãƒŸã‚¹ãƒ†ãƒªãƒ¼ - ç«æŸ´äººæ¢åµã‚²ãƒ¼ãƒ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f5f3e9;
            color: #2c1810;
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* ã‚²ãƒ¼ãƒ ã‚³ãƒ³ãƒ†ãƒŠ */
        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }

        /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
        .game-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0));
        }

        .game-title {
            font-size: 2.5em;
            color: #8b4513;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .game-subtitle {
            font-size: 1.2em;
            color: #666;
        }

        /* ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ */
        .game-area {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        /* ç«æŸ´äººã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¨ãƒªã‚¢ */
        .stick-figure-area {
            background: white;
            border: 3px solid #8b4513;
            border-radius: 10px;
            padding: 20px;
            position: relative;
            min-height: 400px;
        }

        #gameCanvas {
            width: 100%;
            height: 400px;
            border: 1px dashed #ccc;
            cursor: pointer;
        }

        /* ãƒ†ã‚­ã‚¹ãƒˆã¨ãƒ‘ã‚ºãƒ«ã‚¨ãƒªã‚¢ */
        .content-area {
            background: white;
            border: 3px solid #8b4513;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
            max-height: 600px;
        }

        /* ç« ã‚¿ã‚¤ãƒˆãƒ« */
        .chapter-title {
            font-size: 1.8em;
            color: #8b4513;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #8b4513;
        }

        /* ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤ºã‚¨ãƒªã‚¢ */
        .text-display {
            background: #fefefe;
            padding: 15px;
            border-left: 4px solid #d4a574;
            margin-bottom: 20px;
            font-size: 1.1em;
            line-height: 1.8;
        }

        .original-text {
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px dotted #ccc;
        }

        /* ãƒ‘ã‚ºãƒ«ã‚¨ãƒªã‚¢ */
        .puzzle-area {
            background: #f9f7f3;
            border: 2px dashed #8b4513;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .puzzle-title {
            font-size: 1.4em;
            color: #8b4513;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .puzzle-icon {
            font-size: 1.5em;
        }

        .puzzle-progress {
            font-size: 0.9em;
            color: #666;
            margin-left: auto;
        }

        /* ã‚¯ã‚¤ã‚ºãƒ»ãƒ‘ã‚ºãƒ«è¦ç´  */
        .quiz-question {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #333;
        }

        .quiz-options {
            display: grid;
            gap: 10px;
            margin-top: 15px;
        }

        .quiz-option {
            background: white;
            border: 2px solid #d4a574;
            border-radius: 5px;
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1em;
            position: relative;
            overflow: hidden;
        }

        .quiz-option:hover {
            background: #f4e6d7;
            transform: translateX(5px);
            border-color: #8b4513;
        }

        .quiz-option.correct {
            background: #90ee90;
            border-color: #228b22;
            animation: correctPulse 0.6s ease;
        }

        .quiz-option.incorrect {
            background: #ffcccb;
            border-color: #dc143c;
            animation: shake 0.5s ease;
        }

        @keyframes correctPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* ãƒ’ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ  */
        .hint-box {
            background: #fffacd;
            border: 1px solid #daa520;
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .hint-button {
            background: #daa520;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 10px;
        }

        .hint-button:hover {
            background: #b8860b;
        }

        /* é€²è¡ŒçŠ¶æ³ãƒãƒ¼ */
        .progress-container {
            margin-bottom: 20px;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #666;
        }

        .progress-bar {
            background: #e0e0e0;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            background: linear-gradient(90deg, #8b4513, #d4a574);
            height: 100%;
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }

        /* æ¨ç†ãƒãƒ¼ãƒˆ */
        .detective-notebook {
            background: #fffef0;
            border: 2px solid #8b4513;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .notebook-title {
            font-size: 1.3em;
            color: #8b4513;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .clue-list {
            list-style: none;
            padding-left: 20px;
        }

        .clue-item {
            margin: 8px 0;
            padding-left: 20px;
            position: relative;
        }

        .clue-item::before {
            content: "ğŸ”";
            position: absolute;
            left: 0;
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ */
        .control-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .control-button {
            background: #8b4513;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            background: #6b3410;
            transform: translateY(-2px);
        }

        .control-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        /* ã‚¹ã‚³ã‚¢è¡¨ç¤º */
        .score-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border: 3px solid #8b4513;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .score-label {
            font-size: 0.9em;
            color: #666;
        }

        .score-value {
            font-size: 1.8em;
            color: #8b4513;
            font-weight: bold;
        }

        /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */
        .animation-preview {
            position: absolute;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.95);
            border: 2px solid #8b4513;
            border-radius: 5px;
            padding: 5px;
            display: none;
            pointer-events: none;
            z-index: 100;
        }

        /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 10px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ */
        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
            }
            
            .stick-figure-area {
                min-height: 300px;
            }
            
            #gameCanvas {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <div class="game-header">
            <h1 class="game-title">å—å±±çµŒãƒŸã‚¹ãƒ†ãƒªãƒ¼</h1>
            <p class="game-subtitle">ç«æŸ´äººæ¢åµã¨å±±æµ·çµŒã®è¬ã‚’è§£ã</p>
        </div>

        <!-- é€²è¡ŒçŠ¶æ³ãƒãƒ¼ -->
        <div class="progress-container">
            <div class="progress-info">
                <span>é€²è¡ŒçŠ¶æ³</span>
                <span id="progressText">0 / 0 ãƒ‘ã‚ºãƒ«å®Œäº†</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
        </div>

        <!-- ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ -->
        <div class="game-area">
            <!-- ç«æŸ´äººè¡¨ç¤ºã‚¨ãƒªã‚¢ -->
            <div class="stick-figure-area">
                <canvas id="gameCanvas"></canvas>
                <div class="animation-preview">
                    <canvas id="previewCanvas" width="100" height="100"></canvas>
                </div>
                <div class="detective-notebook">
                    <h3 class="notebook-title">
                        <span>ğŸ“”</span>
                        <span>æ¢åµãƒãƒ¼ãƒˆ</span>
                    </h3>
                    <ul class="clue-list" id="clueList">
                        <li class="clue-item">ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¦æ‰‹ãŒã‹ã‚Šã‚’é›†ã‚ã‚ˆã†</li>
                    </ul>
                </div>
            </div>

            <!-- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢ -->
            <div class="content-area">
                <h2 class="chapter-title" id="chapterTitle">ã‚²ãƒ¼ãƒ é–‹å§‹ç”»é¢</h2>
                
                <div class="text-display" id="textDisplay">
                    <p>å±±æµ·çµŒã®å—å±±çµŒã«ã¯ã€ä¸æ€è­°ãªç”Ÿãç‰©ã‚„æ¤ç‰©ãŒãŸãã•ã‚“è¨˜éŒ²ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
                    <p>ã‚ãªãŸã¯ç«æŸ´äººæ¢åµã¨ãªã£ã¦ã€å¤ä»£ã®è¬ã‚’è§£ãæ˜ã‹ã—ã¦ãã ã•ã„ã€‚</p>
                    <p>ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚ˆãèª­ã‚“ã§ã€ç”Ÿãç‰©ã®ç‰¹å¾´ã‚’æ¨ç†ã—ã€ãƒ‘ã‚ºãƒ«ã‚’è§£ã„ã¦é€²ã¿ã¾ã—ã‚‡ã†ï¼</p>
                </div>

                <div class="puzzle-area" id="puzzleArea">
                    <h3 class="puzzle-title">
                        <span class="puzzle-icon">ğŸ§©</span>
                        <span>æº–å‚™ã¯ã„ã„ã§ã™ã‹ï¼Ÿ</span>
                    </h3>
                    <div class="control-buttons">
                        <button class="control-button" onclick="startGame()">ã‚²ãƒ¼ãƒ ã‚’å§‹ã‚ã‚‹</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ã‚¹ã‚³ã‚¢è¡¨ç¤º -->
        <div class="score-display">
            <div class="score-label">ã‚¹ã‚³ã‚¢</div>
            <div class="score-value" id="scoreValue">0</div>
        </div>
    </div>

    <!-- ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div class="modal" id="modal">
        <div class="modal-content" id="modalContent">
            <!-- å‹•çš„ã«å†…å®¹ã‚’æŒ¿å…¥ -->
        </div>
    </div>

    <!-- å¤–éƒ¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆèª­ã¿è¾¼ã¿ -->
    <script src="shanhaijing-complete-text.js"></script>
    
    <script>
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†
        const gameState = {
            currentChapter: -1,
            currentPuzzle: 0,
            totalPuzzles: 0,
            completedPuzzles: 0,
            score: 0,
            clues: [],
            solvedPuzzles: [],
            chapters: [],
            animations: {}
        };

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
        const ANIMATION_CONFIG = {
            frameRate: 60,
            creatures: {
                xingxing: { frames: 8, speed: 0.15 },
                lushu: { frames: 10, speed: 0.2 },
                phoenix: { frames: 12, speed: 0.1 },
                default: { frames: 6, speed: 0.15 }
            }
        };

        // ã‚­ãƒ£ãƒ³ãƒã‚¹è¨­å®š
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®š
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ç®¡ç†
        let animationFrame = 0;
        let lastTime = 0;

        // ç«æŸ´äººæç”»é–¢æ•°ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰
        function drawStickFigure(ctx, x, y, type = 'detective', frame = 0, scale = 1) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            ctx.strokeStyle = '#2c1810';
            ctx.lineWidth = 3;
            
            if (type === 'detective') {
                // æ¢åµç«æŸ´äººï¼ˆæ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                const walkOffset = Math.sin(frame * 0.1) * 5;
                
                // é ­
                ctx.beginPath();
                ctx.arc(0, -30 + walkOffset * 0.3, 15, 0, Math.PI * 2);
                ctx.stroke();
                
                // å¸½å­
                ctx.beginPath();
                ctx.moveTo(-20, -35 + walkOffset * 0.3);
                ctx.lineTo(20, -35 + walkOffset * 0.3);
                ctx.lineTo(15, -45 + walkOffset * 0.3);
                ctx.lineTo(-15, -45 + walkOffset * 0.3);
                ctx.closePath();
                ctx.stroke();
                
                // ä½“
                ctx.beginPath();
                ctx.moveTo(0, -15 + walkOffset * 0.3);
                ctx.lineTo(0, 20);
                ctx.stroke();
                
                // è…•ï¼ˆæ­©è¡Œæ™‚ã®æŒ¯ã‚Šï¼‰
                const armSwing = Math.sin(frame * 0.1) * 10;
                ctx.beginPath();
                ctx.moveTo(-15 - armSwing * 0.5, 0);
                ctx.lineTo(0, -5 + walkOffset * 0.3);
                ctx.lineTo(15 + armSwing * 0.5, 0);
                ctx.stroke();
                
                // è™«çœ¼é¡
                ctx.beginPath();
                ctx.arc(25 + armSwing * 0.5, -5, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(20 + armSwing * 0.5, 0);
                ctx.lineTo(15 + armSwing * 0.5, 5);
                ctx.stroke();
                
                // è„šï¼ˆæ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                const legSwing = Math.sin(frame * 0.1) * 15;
                ctx.beginPath();
                ctx.moveTo(0, 20);
                ctx.lineTo(-10 - legSwing, 40);
                ctx.moveTo(0, 20);
                ctx.lineTo(10 + legSwing, 40);
                ctx.stroke();
            } else if (type === 'celebration') {
                // æ­£è§£æ™‚ã®å–œã³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                const jumpHeight = Math.abs(Math.sin(frame * 0.2)) * 20;
                const armRaise = Math.sin(frame * 0.3) * 30;
                
                // é ­
                ctx.beginPath();
                ctx.arc(0, -30 - jumpHeight, 15, 0, Math.PI * 2);
                ctx.stroke();
                
                // ç¬‘é¡”
                ctx.beginPath();
                ctx.arc(0, -25 - jumpHeight, 8, 0, Math.PI);
                ctx.stroke();
                
                // ä½“
                ctx.beginPath();
                ctx.moveTo(0, -15 - jumpHeight);
                ctx.lineTo(0, 20 - jumpHeight);
                ctx.stroke();
                
                // è…•ï¼ˆä¸Šã’ä¸‹ã’ï¼‰
                ctx.beginPath();
                ctx.moveTo(-15, -5 - jumpHeight);
                ctx.lineTo(0, -5 - jumpHeight);
                ctx.lineTo(15, -5 - jumpHeight - armRaise);
                ctx.stroke();
                
                // è„š
                ctx.beginPath();
                ctx.moveTo(0, 20 - jumpHeight);
                ctx.lineTo(-10, 40);
                ctx.moveTo(0, 20 - jumpHeight);
                ctx.lineTo(10, 40);
                ctx.stroke();
            } else if (type === 'wrong') {
                // ä¸æ­£è§£æ™‚ã®é¦–æŒ¯ã‚Šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                const headShake = Math.sin(frame * 0.3) * 10;
                
                // é ­ï¼ˆé¦–æŒ¯ã‚Šï¼‰
                ctx.beginPath();
                ctx.arc(headShake, -30, 15, 0, Math.PI * 2);
                ctx.stroke();
                
                // å›°ã£ãŸé¡”
                ctx.beginPath();
                ctx.moveTo(headShake - 5, -25);
                ctx.lineTo(headShake + 5, -25);
                ctx.stroke();
                
                // ä½“
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(0, 20);
                ctx.stroke();
                
                // è…•ï¼ˆä¸‹ã’æ°—å‘³ï¼‰
                ctx.beginPath();
                ctx.moveTo(-15, 5);
                ctx.lineTo(0, -5);
                ctx.lineTo(15, 5);
                ctx.stroke();
                
                // è„š
                ctx.beginPath();
                ctx.moveTo(0, 20);
                ctx.lineTo(-10, 40);
                ctx.moveTo(0, 20);
                ctx.lineTo(10, 40);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // ç”Ÿãç‰©ã‚’ç«æŸ´äººã‚¹ã‚¿ã‚¤ãƒ«ã§æç”»ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰
        function drawCreature(ctx, x, y, creatureData, frame = 0, scale = 1) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            
            switch(creatureData.type) {
                case 'xingxing': // ç‹Œç‹Œï¼ˆäººã®ã‚ˆã†ã«æ­©ãçŒ¿ï¼‰
                    const walkCycle = Math.sin(frame * 0.15) * 10;
                    const armSwing = Math.sin(frame * 0.15 + Math.PI) * 15;
                    
                    // é ­
                    ctx.beginPath();
                    ctx.arc(0, -20 + Math.abs(walkCycle) * 0.3, 12, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ç™½ã„è€³ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(-15, -22 + Math.abs(walkCycle) * 0.3, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(15, -22 + Math.abs(walkCycle) * 0.3, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // ä½“ï¼ˆç›´ç«‹æ­©è¡Œï¼‰
                    ctx.beginPath();
                    ctx.moveTo(0, -8 + Math.abs(walkCycle) * 0.3);
                    ctx.lineTo(0, 15);
                    ctx.stroke();
                    
                    // è…•ï¼ˆäººé–“ã®ã‚ˆã†ãªæŒ¯ã‚Šï¼‰
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(0, -5 + Math.abs(walkCycle) * 0.3);
                    ctx.lineTo(10, 0 - armSwing * 0.5);
                    ctx.stroke();
                    
                    // è„šï¼ˆäºŒè¶³æ­©è¡Œï¼‰
                    ctx.beginPath();
                    ctx.moveTo(0, 15);
                    ctx.lineTo(-8 - walkCycle * 0.5, 30);
                    ctx.moveTo(0, 15);
                    ctx.lineTo(8 + walkCycle * 0.5, 30);
                    ctx.stroke();
                    
                    // å¹ãå‡ºã—ï¼ˆåå‰ã‚’å‘¼ã¶ï¼‰
                    if (frame % 120 < 60) {
                        ctx.beginPath();
                        ctx.moveTo(20, -25);
                        ctx.lineTo(30, -35);
                        ctx.lineTo(50, -35);
                        ctx.lineTo(50, -45);
                        ctx.lineTo(30, -45);
                        ctx.lineTo(25, -35);
                        ctx.closePath();
                        ctx.stroke();
                        ctx.fillStyle = '#2c1810';
                        ctx.font = '10px sans-serif';
                        ctx.fillText('åå‰ï¼', 32, -38);
                    }
                    break;
                    
                case 'lushu': // é¹¿èœ€ï¼ˆè™ç¸ã®é¦¬ï¼‰
                    const gallop = Math.sin(frame * 0.2) * 5;
                    const legCycle = frame * 0.2;
                    
                    // é ­ï¼ˆé¦¬ï¼‰
                    ctx.beginPath();
                    ctx.ellipse(0, -25 + gallop, 10, 15, Math.PI * 0.1, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ä½“ï¼ˆæ¨ªé•·ï¼‰
                    ctx.beginPath();
                    ctx.ellipse(0, 0 + gallop, 25, 15, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // è™ç¸æ¨¡æ§˜
                    ctx.strokeStyle = '#ff8c00';
                    for (let i = -20; i <= 20; i += 8) {
                        ctx.beginPath();
                        ctx.moveTo(i, -10 + gallop);
                        ctx.lineTo(i + 3, 10 + gallop);
                        ctx.stroke();
                    }
                    ctx.strokeStyle = '#8b4513';
                    
                    // è„šï¼ˆèµ°è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                    const legs = [
                        { x: -15, phase: 0 },
                        { x: -8, phase: Math.PI },
                        { x: 8, phase: Math.PI * 0.5 },
                        { x: 15, phase: Math.PI * 1.5 }
                    ];
                    
                    legs.forEach(leg => {
                        const legHeight = Math.sin(legCycle + leg.phase) * 10;
                        ctx.beginPath();
                        ctx.moveTo(leg.x, 15 + gallop);
                        ctx.lineTo(leg.x, 25 + legHeight);
                        ctx.stroke();
                    });
                    
                    // å°¾
                    const tailSwing = Math.sin(frame * 0.15) * 20;
                    ctx.beginPath();
                    ctx.moveTo(25, 0 + gallop);
                    ctx.quadraticCurveTo(35 + tailSwing * 0.5, 5 + gallop, 30 + tailSwing, 15 + gallop);
                    ctx.stroke();
                    break;
                    
                case 'phoenix': // é³³å‡°ï¼ˆé£›ç¿”ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                    const flyHeight = Math.sin(frame * 0.1) * 10;
                    const wingFlap = Math.sin(frame * 0.3) * 30;
                    
                    // äººã®é ­
                    ctx.beginPath();
                    ctx.arc(0, -25 + flyHeight, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ç‹å† 
                    ctx.beginPath();
                    ctx.moveTo(-8, -35 + flyHeight);
                    ctx.lineTo(-4, -40 + flyHeight);
                    ctx.lineTo(0, -38 + flyHeight);
                    ctx.lineTo(4, -40 + flyHeight);
                    ctx.lineTo(8, -35 + flyHeight);
                    ctx.stroke();
                    
                    // ä½“ï¼ˆé³¥ï¼‰
                    ctx.beginPath();
                    ctx.ellipse(0, 0 + flyHeight, 15, 20, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ç¿¼ï¼ˆç¾½ã°ãŸãï¼‰
                    ctx.beginPath();
                    ctx.moveTo(-15, -5 + flyHeight);
                    ctx.quadraticCurveTo(-30 - wingFlap, -10 + flyHeight - wingFlap * 0.5, -25 - wingFlap, 5 + flyHeight);
                    ctx.moveTo(15, -5 + flyHeight);
                    ctx.quadraticCurveTo(30 + wingFlap, -10 + flyHeight - wingFlap * 0.5, 25 + wingFlap, 5 + flyHeight);
                    ctx.stroke();
                    
                    // ç¾½æ ¹ã®è©³ç´°
                    ctx.strokeStyle = '#d4a574';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-20 - wingFlap + i * 5, -5 + flyHeight - wingFlap * 0.3);
                        ctx.lineTo(-22 - wingFlap + i * 5, 0 + flyHeight);
                        ctx.moveTo(20 + wingFlap - i * 5, -5 + flyHeight - wingFlap * 0.3);
                        ctx.lineTo(22 + wingFlap - i * 5, 0 + flyHeight);
                        ctx.stroke();
                    }
                    ctx.strokeStyle = '#8b4513';
                    ctx.lineWidth = 2;
                    
                    // å°¾ï¼ˆå„ªé›…ã«æºã‚Œã‚‹ï¼‰
                    const tailSway = Math.sin(frame * 0.08) * 10;
                    ctx.beginPath();
                    ctx.moveTo(0, 20 + flyHeight);
                    ctx.lineTo(-5 + tailSway * 0.3, 30 + flyHeight);
                    ctx.moveTo(0, 20 + flyHeight);
                    ctx.lineTo(0 + tailSway * 0.5, 32 + flyHeight);
                    ctx.moveTo(0, 20 + flyHeight);
                    ctx.lineTo(5 + tailSway * 0.3, 30 + flyHeight);
                    ctx.stroke();
                    
                    // è¼ãã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    if (frame % 60 < 30) {
                        ctx.strokeStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(0, -10 + flyHeight, 25, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    break;
                    
                case 'plant_effect': // æ¤ç‰©åŠ¹æœãƒ‡ãƒ¢ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    const eatCycle = frame % 180;
                    
                    // åŸºæœ¬ã®ç«æŸ´äºº
                    ctx.beginPath();
                    ctx.arc(0, -20, 12, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(0, 15);
                    ctx.stroke();
                    
                    // è…•ï¼ˆé£Ÿã¹ã‚‹å‹•ä½œï¼‰
                    if (eatCycle < 60) {
                        const handMove = eatCycle / 60;
                        ctx.beginPath();
                        ctx.moveTo(-10, 0);
                        ctx.lineTo(0, -5);
                        ctx.lineTo(10 - handMove * 10, -5 - handMove * 15);
                        ctx.stroke();
                        
                        // æ¤ç‰©
                        ctx.fillStyle = '#90ee90';
                        ctx.beginPath();
                        ctx.arc(10 - handMove * 10, -5 - handMove * 15, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        // åŠ¹æœç™ºå‹•
                        ctx.beginPath();
                        ctx.moveTo(-10, -10);
                        ctx.lineTo(0, -5);
                        ctx.lineTo(10, -10);
                        ctx.stroke();
                        
                        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                        const effectRadius = (eatCycle - 60) / 120 * 30;
                        ctx.strokeStyle = '#32cd32';
                        ctx.beginPath();
                        ctx.arc(0, 0, effectRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // åŠ¹æœãƒ†ã‚­ã‚¹ãƒˆ
                        if (creatureData.effect) {
                            ctx.fillStyle = '#228b22';
                            ctx.font = '12px sans-serif';
                            ctx.fillText(creatureData.effect, -30, -40);
                        }
                    }
                    
                    // è„š
                    ctx.strokeStyle = '#8b4513';
                    ctx.beginPath();
                    ctx.moveTo(0, 15);
                    ctx.lineTo(-8, 30);
                    ctx.moveTo(0, 15);
                    ctx.lineTo(8, 30);
                    ctx.stroke();
                    break;
                    
                case 'direction': // æ–¹å‘æŒ‡ç¤ºã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    const pointCycle = Math.sin(frame * 0.1) * 10;
                    
                    // é ­
                    ctx.beginPath();
                    ctx.arc(0, -20, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ä½“
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(0, 15);
                    ctx.stroke();
                    
                    // æŒ‡å·®ã—è…•
                    const direction = creatureData.direction || 'east';
                    let armAngle = 0;
                    switch(direction) {
                        case 'east': armAngle = 0; break;
                        case 'west': armAngle = Math.PI; break;
                        case 'north': armAngle = -Math.PI / 2; break;
                        case 'south': armAngle = Math.PI / 2; break;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -5);
                    ctx.lineTo(
                        Math.cos(armAngle) * (20 + pointCycle),
                        -5 + Math.sin(armAngle) * (20 + pointCycle)
                    );
                    ctx.stroke();
                    
                    // çŸ¢å°
                    ctx.save();
                    ctx.translate(
                        Math.cos(armAngle) * (25 + pointCycle),
                        -5 + Math.sin(armAngle) * (25 + pointCycle)
                    );
                    ctx.rotate(armAngle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-5, -5);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-5, 5);
                    ctx.stroke();
                    ctx.restore();
                    
                    // ã‚‚ã†ç‰‡æ–¹ã®è…•
                    ctx.beginPath();
                    ctx.moveTo(0, -5);
                    ctx.lineTo(-10, 0);
                    ctx.stroke();
                    
                    // è„š
                    ctx.beginPath();
                    ctx.moveTo(0, 15);
                    ctx.lineTo(-8, 30);
                    ctx.moveTo(0, 15);
                    ctx.lineTo(8, 30);
                    ctx.stroke();
                    
                    // æ–¹å‘ãƒ†ã‚­ã‚¹ãƒˆ
                    ctx.fillStyle = '#8b4513';
                    ctx.font = '14px sans-serif';
                    const dirText = {
                        'east': 'æ±ã¸â†’',
                        'west': 'â†è¥¿ã¸',
                        'north': 'â†‘åŒ—ã¸',
                        'south': 'å—ã¸â†“'
                    };
                    ctx.fillText(dirText[direction] || '', -20, -40);
                    break;
            }
            
            ctx.restore();
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (deltaTime > 16) { // 60fpsåˆ¶é™
                animationFrame++;
                
                // ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(255, 250, 240, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 248, 220, 0.5)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // æ¢åµã‚’æç”»
                drawStickFigure(ctx, 150, canvas.height / 2 + 50, gameState.animations.detective || 'detective', animationFrame);
                
                // ç¾åœ¨ã®ã‚¯ãƒªãƒ¼ãƒãƒ£ãƒ¼ã‚’æç”»
                if (gameState.animations.creature) {
                    drawCreature(ctx, canvas.width - 200, canvas.height / 2 + 50, gameState.animations.creature, animationFrame);
                }
                
                // è¿½åŠ ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¦ç´ 
                if (gameState.animations.extras) {
                    gameState.animations.extras.forEach(extra => {
                        if (extra.type === 'celebration') {
                            drawStickFigure(ctx, extra.x, extra.y, 'celebration', animationFrame, 0.8);
                        }
                    });
                }
            }
            
            requestAnimationFrame(animate);
        }

        // ãƒ‘ã‚ºãƒ«ç”Ÿæˆé–¢æ•°
        function generatePuzzle(chapterData, puzzleIndex) {
            const puzzleTypes = [
                'creature_identification',
                'property_matching',
                'text_analysis',
                'location_puzzle'
            ];
            
            const type = puzzleTypes[puzzleIndex % puzzleTypes.length];
            
            switch(type) {
                case 'creature_identification':
                    return generateCreatureIdentificationPuzzle(chapterData);
                case 'property_matching':
                    return generatePropertyMatchingPuzzle(chapterData);
                case 'text_analysis':
                    return generateTextAnalysisPuzzle(chapterData);
                case 'location_puzzle':
                    return generateLocationPuzzle(chapterData);
            }
        }

        // ç”Ÿãç‰©è­˜åˆ¥ãƒ‘ã‚ºãƒ«
        function generateCreatureIdentificationPuzzle(chapterData) {
            const creatures = extractCreatures(chapterData);
            if (creatures.length === 0) return null;
            
            const targetCreature = creatures[Math.floor(Math.random() * creatures.length)];
            const question = `æ¬¡ã®ç‰¹å¾´ã‚’æŒã¤ç”Ÿãç‰©ã¯ä½•ã§ã—ã‚‡ã†ï¼Ÿ\n${targetCreature.description}`;
            
            const options = [
                targetCreature.name,
                'å¤©ç‹—',
                'éº’éºŸ',
                'é¾'
            ].sort(() => Math.random() - 0.5);
            
            return {
                type: 'creature',
                question: question,
                options: options,
                correct: targetCreature.name,
                hint: `ãƒ’ãƒ³ãƒˆï¼š${chapterData.title}ã«ç™»å ´ã™ã‚‹ç”Ÿãç‰©ã§ã™ã€‚`,
                creatureData: targetCreature
            };
        }

        // ç‰¹æ€§ãƒãƒƒãƒãƒ³ã‚°ãƒ‘ã‚ºãƒ«
        function generatePropertyMatchingPuzzle(chapterData) {
            const properties = extractProperties(chapterData);
            if (properties.length === 0) return null;
            
            const targetProperty = properties[Math.floor(Math.random() * properties.length)];
            const question = `ã€Œ${targetProperty.item}ã€ã®åŠ¹æœã¯ä½•ã§ã—ã‚‡ã†ï¼Ÿ`;
            
            const options = [
                targetProperty.effect,
                'ç—…æ°—ã‚’æ²»ã™',
                'é•·å¯¿ã‚’ã‚‚ãŸã‚‰ã™',
                'å¯Œã‚’ã‚‚ãŸã‚‰ã™'
            ].sort(() => Math.random() - 0.5);
            
            return {
                type: 'property',
                question: question,
                options: options,
                correct: targetProperty.effect,
                hint: `ãƒ’ãƒ³ãƒˆï¼šåŸæ–‡ã‚’ã‚ˆãèª­ã‚“ã§ã¿ã¾ã—ã‚‡ã†ã€‚`,
                propertyData: targetProperty
            };
        }

        // ãƒ†ã‚­ã‚¹ãƒˆåˆ†æãƒ‘ã‚ºãƒ«
        function generateTextAnalysisPuzzle(chapterData) {
            const question = `${chapterData.title}ã®èˆå°ã¨ãªã‚‹å±±ã®ç‰¹å¾´ã¯ï¼Ÿ`;
            const features = extractMountainFeatures(chapterData);
            
            if (features.length === 0) return null;
            
            const correct = features[0];
            const options = [
                correct,
                'æ±ã®æµ·ã«é¢ã—ã¦ã„ã‚‹',
                'é›ªãŒä¸€å¹´ä¸­ç©ã‚‚ã£ã¦ã„ã‚‹',
                'äººãŒä½ã‚“ã§ã„ã‚‹'
            ].sort(() => Math.random() - 0.5);
            
            return {
                type: 'text',
                question: question,
                options: options,
                correct: correct,
                hint: `ãƒ’ãƒ³ãƒˆï¼šå±±ã®ä½ç½®ã‚„ç‰¹å¾´ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚`
            };
        }

        // ä½ç½®ãƒ‘ã‚ºãƒ«
        function generateLocationPuzzle(chapterData) {
            const locations = extractLocations(chapterData);
            if (locations.length === 0) return null;
            
            const question = `ã“ã®ç« ã«ç™»å ´ã™ã‚‹å·ã¯ã©ã“ã«æµã‚Œã¦ã„ã¾ã™ã‹ï¼Ÿ`;
            const correct = locations[0].destination;
            
            const options = [
                correct,
                'æ±ã®æ¹–',
                'åŒ—ã®å¤§æ²³',
                'å—ã®æ²¼'
            ].sort(() => Math.random() - 0.5);
            
            const directionMap = {
                'æµ·': 'east',
                'æ±ã®æ¹–': 'east',
                'åŒ—ã®å¤§æ²³': 'north',
                'å—ã®æ²¼': 'south'
            };
            
            return {
                type: 'location',
                question: question,
                options: options,
                correct: correct,
                hint: `ãƒ’ãƒ³ãƒˆï¼šæ°´ã®æµã‚Œã‚‹æ–¹å‘ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚`,
                locationData: { direction: directionMap[correct] || 'east' }
            };
        }

        // ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºé–¢æ•°
        function extractCreatures(chapterData) {
            const creatures = [];
            const text = chapterData.japanese;
            
            // ç‹Œç‹Œã®æŠ½å‡º
            if (text.includes('ç‹Œç‹Œ')) {
                creatures.push({
                    name: 'ç‹Œç‹Œï¼ˆã›ã„ã›ã„ï¼‰',
                    description: 'çŒ¿ã«ä¼¼ã¦ç™½ã„è€³ã‚’æŒã¡ã€åœ°ã‚’é€™ã†ã‚ˆã†ã«é€²ã¿äººã®ã‚ˆã†ã«èµ°ã‚‹',
                    type: 'xingxing'
                });
            }
            
            // é¹¿èœ€ã®æŠ½å‡º
            if (text.includes('é¹¿èœ€')) {
                creatures.push({
                    name: 'é¹¿èœ€ï¼ˆã‚ãã—ã‚‡ãï¼‰',
                    description: 'é¦¬ã®ã‚ˆã†ãªå½¢ã§ç™½ã„é ­ã€è™ã®ã‚ˆã†ãªæ¨¡æ§˜ã‚’æŒã¤',
                    type: 'lushu'
                });
            }
            
            // è²åŠ›ã®æŠ½å‡º
            if (text.includes('è²åŠ›')) {
                creatures.push({
                    name: 'è²åŠ›ï¼ˆã‚Šã‚Šã‚‡ãï¼‰',
                    description: 'è±šã«ä¼¼ãŸå½¢ã§è¹´çˆªã‚’æŒã¡ã€çŠ¬ãŒå ãˆã‚‹ã‚ˆã†ãªå£°ã‚’å‡ºã™',
                    type: 'lushu' // ä¸€æ™‚çš„ã«é¹¿èœ€ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨
                });
            }
            
            // é³³å‡°ã®æŠ½å‡º
            if (text.includes('é³³çš‡')) {
                creatures.push({
                    name: 'é³³çš‡ï¼ˆã»ã†ãŠã†ï¼‰',
                    description: 'é´Ÿï¼ˆã¨ã³ï¼‰ã®ã‚ˆã†ãªå½¢ã§äººã®é ­ã‚’æŒã¤',
                    type: 'phoenix'
                });
            }
            
            return creatures;
        }

        function extractProperties(chapterData) {
            const properties = [];
            const text = chapterData.japanese;
            
            if (text.includes('ç¥é¤˜')) {
                properties.push({
                    item: 'ç¥é¤˜ï¼ˆã—ã‚…ãã‚ˆï¼‰',
                    effect: 'é£Ÿã¹ã‚‹ã¨é£¢ãˆã‚‹ã“ã¨ãŒãªã„',
                    type: 'plant_effect'
                });
            }
            
            if (text.includes('è¿·ç©€')) {
                properties.push({
                    item: 'è¿·ç©€ï¼ˆã‚ã„ã“ãï¼‰',
                    effect: 'èº«ã«ã¤ã‘ã‚‹ã¨é“ã«è¿·ã‚ãªã„',
                    type: 'plant_effect'
                });
            }
            
            if (text.includes('è‚²æ²›')) {
                properties.push({
                    item: 'è‚²æ²›ï¼ˆã„ãã¯ã„ï¼‰',
                    effect: 'èº«ã«ã¤ã‘ã‚‹ã¨ç—…æ°—ã«ã‹ã‹ã‚‰ãªã„',
                    type: 'plant_effect'
                });
            }
            
            return properties;
        }

        function extractMountainFeatures(chapterData) {
            const features = [];
            const text = chapterData.japanese;
            
            if (text.includes('è¥¿ã®æµ·ã‚’è¦‹ä¸‹ã‚ã—')) {
                features.push('è¥¿ã®æµ·ã‚’è¦‹ä¸‹ã‚ã™ä½ç½®ã«ã‚ã‚‹');
            }
            
            if (text.includes('æ¡‚ã®æœ¨ãŒå¤šã')) {
                features.push('æ¡‚ã®æœ¨ãŒå¤šãç”Ÿãˆã¦ã„ã‚‹');
            }
            
            if (text.includes('é‡‘ã‚„ç‰ã‚‚è±Šå¯Œ')) {
                features.push('é‡‘ã‚„ç‰ãŒè±Šå¯Œã«ç”£å‡ºã•ã‚Œã‚‹');
            }
            
            return features;
        }

        function extractLocations(chapterData) {
            const locations = [];
            const text = chapterData.japanese;
            
            const riverMatch = text.match(/(.+?)ã¨ã„ã†å·ãŒ.+?æµã‚Œ.+?([^ã«]+?)ã«æ³¨ã/);
            if (riverMatch) {
                locations.push({
                    river: riverMatch[1],
                    destination: riverMatch[2]
                });
            }
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
            if (locations.length === 0 && text.includes('æµ·ã«æ³¨ã')) {
                locations.push({
                    river: 'å·',
                    destination: 'æµ·'
                });
            }
            
            return locations;
        }

        // ç·ãƒ‘ã‚ºãƒ«æ•°ã‚’è¨ˆç®—
        function calculateTotalPuzzles() {
            const puzzlesPerChapter = 3;
            return gameState.chapters.length * puzzlesPerChapter;
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹é–¢æ•°
        function startGame() {
            gameState.currentChapter = 0;
            gameState.currentPuzzle = 0;
            gameState.completedPuzzles = 0;
            gameState.score = 0;
            gameState.clues = [];
            gameState.chapters = window.SHANHAIJING_COMPLETE.nanshan.chapters;
            gameState.totalPuzzles = calculateTotalPuzzles();
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
            gameState.animations = {
                detective: 'detective',
                creature: null,
                extras: []
            };
            
            loadChapter(0);
            updateProgress();
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—é–‹å§‹
            requestAnimationFrame(animate);
        }

        // ç« ã®èª­ã¿è¾¼ã¿
        function loadChapter(chapterIndex) {
            if (chapterIndex >= gameState.chapters.length) {
                showGameComplete();
                return;
            }
            
            const chapter = gameState.chapters[chapterIndex];
            gameState.currentChapter = chapterIndex;
            gameState.currentPuzzle = 0;
            
            // UIæ›´æ–°
            document.getElementById('chapterTitle').textContent = chapter.title;
            document.getElementById('textDisplay').innerHTML = `
                <p>${chapter.japanese}</p>
                <div class="original-text">
                    <strong>åŸæ–‡ï¼š</strong>${chapter.original}
                </div>
            `;
            
            // ç« ã«é–¢é€£ã™ã‚‹ç”Ÿãç‰©ã‚’è¨­å®š
            const creatures = extractCreatures(chapter);
            if (creatures.length > 0) {
                gameState.animations.creature = creatures[0];
            } else {
                gameState.animations.creature = null;
            }
            
            // æœ€åˆã®ãƒ‘ã‚ºãƒ«ã‚’è¡¨ç¤º
            showNextPuzzle();
        }

        // æ¬¡ã®ãƒ‘ã‚ºãƒ«ã‚’è¡¨ç¤º
        function showNextPuzzle() {
            const chapter = gameState.chapters[gameState.currentChapter];
            const puzzle = generatePuzzle(chapter, gameState.currentPuzzle);
            
            if (!puzzle || gameState.currentPuzzle >= 3) {
                // ãƒ‘ã‚ºãƒ«ãŒãªã„å ´åˆã¯æ¬¡ã®ç« ã¸
                loadChapter(gameState.currentChapter + 1);
                return;
            }
            
            displayPuzzle(puzzle);
        }

        // ãƒ‘ã‚ºãƒ«ã®è¡¨ç¤º
        function displayPuzzle(puzzle) {
            const puzzleArea = document.getElementById('puzzleArea');
            
            // ç¾åœ¨ã®ãƒ‘ã‚ºãƒ«ç•ªå·ã‚’è¨ˆç®—
            const currentPuzzleNumber = gameState.currentChapter * 3 + gameState.currentPuzzle + 1;
            
            let puzzleHTML = `
                <h3 class="puzzle-title">
                    <span class="puzzle-icon">ğŸ§©</span>
                    <span>è¬è§£ã ${gameState.currentPuzzle + 1}</span>
                    <span class="puzzle-progress">(${currentPuzzleNumber} / ${gameState.totalPuzzles})</span>
                </h3>
                <div class="quiz-question">${puzzle.question}</div>
                <div class="quiz-options">
            `;
            
            puzzle.options.forEach((option, index) => {
                puzzleHTML += `
                    <div class="quiz-option" 
                         data-option="${option}" 
                         data-index="${index}"
                         onmouseover="previewAnimation(this, '${puzzle.type}', ${index})"
                         onmouseout="hidePreview()"
                         onclick="checkAnswer('${option}', '${puzzle.correct}', this, '${puzzle.type}')">
                        ${option}
                    </div>
                `;
            });
            
            puzzleHTML += `
                </div>
                <button class="hint-button" onclick="showHint('${puzzle.hint}')">ãƒ’ãƒ³ãƒˆã‚’è¦‹ã‚‹</button>
                <div class="hint-box" id="hintBox"></div>
            `;
            
            puzzleArea.innerHTML = puzzleHTML;
            
            // ãƒ‘ã‚ºãƒ«ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ›´æ–°
            if (puzzle.type === 'creature' && puzzle.creatureData) {
                gameState.animations.creature = puzzle.creatureData;
            } else if (puzzle.type === 'property' && puzzle.propertyData) {
                gameState.animations.creature = {
                    type: 'plant_effect',
                    effect: puzzle.propertyData.effect
                };
            } else if (puzzle.type === 'location' && puzzle.locationData) {
                gameState.animations.creature = {
                    type: 'direction',
                    direction: puzzle.locationData.direction
                };
            }
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
        function previewAnimation(element, puzzleType, optionIndex) {
            const preview = document.querySelector('.animation-preview');
            const rect = element.getBoundingClientRect();
            
            preview.style.display = 'block';
            preview.style.left = '50%';
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«åŸºã¥ã„ã¦ç°¡å˜ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
            if (puzzleType === 'creature') {
                drawStickFigure(previewCtx, 50, 70, 'detective', animationFrame * 2, 0.6);
            } else if (puzzleType === 'property') {
                drawCreature(previewCtx, 50, 70, { type: 'plant_effect', effect: '?' }, animationFrame * 2, 0.6);
            } else if (puzzleType === 'location') {
                const directions = ['east', 'north', 'west', 'south'];
                drawCreature(previewCtx, 50, 70, { type: 'direction', direction: directions[optionIndex] }, animationFrame * 2, 0.6);
            }
        }

        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’éš ã™
        function hidePreview() {
            document.querySelector('.animation-preview').style.display = 'none';
        }

        // ç­”ãˆã‚’ãƒã‚§ãƒƒã‚¯
        function checkAnswer(selected, correct, element, puzzleType) {
            const options = document.querySelectorAll('.quiz-option');
            options.forEach(opt => {
                opt.onclick = null;
                opt.onmouseover = null;
                opt.onmouseout = null;
            });
            
            if (selected === correct) {
                element.classList.add('correct');
                gameState.score += 100;
                gameState.completedPuzzles++;
                updateScore();
                updateProgress();
                
                // æ­£è§£ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                gameState.animations.detective = 'celebration';
                gameState.animations.extras = [
                    { type: 'celebration', x: 250, y: canvas.height / 2 + 50 },
                    { type: 'celebration', x: 350, y: canvas.height / 2 + 50 }
                ];
                
                // æ‰‹ãŒã‹ã‚Šã‚’è¿½åŠ 
                addClue(`${gameState.chapters[gameState.currentChapter].title}ã®è¬ã‚’è§£æ˜ï¼`);
                
                setTimeout(() => {
                    gameState.animations.detective = 'detective';
                    gameState.animations.extras = [];
                    gameState.currentPuzzle++;
                    
                    if (gameState.currentPuzzle >= 3) {
                        // ç« ã‚¯ãƒªã‚¢
                        showChapterComplete();
                    } else {
                        showNextPuzzle();
                    }
                }, 2000);
            } else {
                element.classList.add('incorrect');
                gameState.score = Math.max(0, gameState.score - 20);
                updateScore();
                
                // ä¸æ­£è§£ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                gameState.animations.detective = 'wrong';
                
                // æ­£è§£ã‚’è¡¨ç¤º
                options.forEach(opt => {
                    if (opt.textContent.trim() === correct) {
                        opt.classList.add('correct');
                    }
                });
                
                setTimeout(() => {
                    gameState.animations.detective = 'detective';
                    gameState.currentPuzzle++;
                    
                    if (gameState.currentPuzzle >= 3) {
                        showChapterComplete();
                    } else {
                        showNextPuzzle();
                    }
                }, 2500);
            }
        }

        // ãƒ’ãƒ³ãƒˆè¡¨ç¤º
        function showHint(hint) {
            const hintBox = document.getElementById('hintBox');
            hintBox.style.display = 'block';
            hintBox.innerHTML = `<strong>ãƒ’ãƒ³ãƒˆï¼š</strong> ${hint}`;
            
            // ã‚¹ã‚³ã‚¢ã‚’å°‘ã—æ¸›ã‚‰ã™
            gameState.score = Math.max(0, gameState.score - 10);
            updateScore();
        }

        // æ‰‹ãŒã‹ã‚Šã‚’è¿½åŠ 
        function addClue(clue) {
            gameState.clues.push(clue);
            updateClueList();
        }

        // æ‰‹ãŒã‹ã‚Šãƒªã‚¹ãƒˆã‚’æ›´æ–°
        function updateClueList() {
            const clueList = document.getElementById('clueList');
            clueList.innerHTML = gameState.clues.map(clue => 
                `<li class="clue-item">${clue}</li>`
            ).join('');
        }

        // ã‚¹ã‚³ã‚¢æ›´æ–°
        function updateScore() {
            document.getElementById('scoreValue').textContent = gameState.score;
        }

        // é€²è¡ŒçŠ¶æ³æ›´æ–°
        function updateProgress() {
            const progressPercent = (gameState.completedPuzzles / gameState.totalPuzzles) * 100;
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            progressFill.style.width = progressPercent + '%';
            progressFill.textContent = Math.round(progressPercent) + '%';
            progressText.textContent = `${gameState.completedPuzzles} / ${gameState.totalPuzzles} ãƒ‘ã‚ºãƒ«å®Œäº†`;
        }

        // ç« ã‚¯ãƒªã‚¢è¡¨ç¤º
        function showChapterComplete() {
            const modal = document.getElementById('modal');
            const modalContent = document.getElementById('modalContent');
            
            modalContent.innerHTML = `
                <h2 style="color: #8b4513; margin-bottom: 20px;">ç« ã‚¯ãƒªã‚¢ï¼</h2>
                <p style="font-size: 1.2em; margin-bottom: 20px;">
                    ${gameState.chapters[gameState.currentChapter].title}ã®è¬ã‚’è§£ãæ˜ã‹ã—ã¾ã—ãŸï¼
                </p>
                <p style="color: #666; margin-bottom: 20px;">
                    ç²å¾—ã‚¹ã‚³ã‚¢: +300
                </p>
                <button class="control-button" onclick="closeModal(); loadChapter(${gameState.currentChapter + 1});">
                    æ¬¡ã®ç« ã¸é€²ã‚€
                </button>
            `;
            
            modal.style.display = 'flex';
            gameState.score += 300;
            updateScore();
        }

        // ã‚²ãƒ¼ãƒ å®Œäº†è¡¨ç¤º
        function showGameComplete() {
            const modal = document.getElementById('modal');
            const modalContent = document.getElementById('modalContent');
            
            const completionRate = Math.round((gameState.completedPuzzles / gameState.totalPuzzles) * 100);
            
            modalContent.innerHTML = `
                <h2 style="color: #8b4513; margin-bottom: 20px;">ğŸ‰ ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼ ğŸ‰</h2>
                <p style="font-size: 1.2em; margin-bottom: 20px;">
                    å—å±±çµŒã®ã™ã¹ã¦ã®è¬ã‚’è§£ãæ˜ã‹ã—ã¾ã—ãŸï¼
                </p>
                <p style="font-size: 1.5em; color: #8b4513; margin-bottom: 20px;">
                    æœ€çµ‚ã‚¹ã‚³ã‚¢: ${gameState.score}
                </p>
                <p style="color: #666; margin-bottom: 10px;">
                    å®Œäº†ç‡: ${completionRate}%
                </p>
                <p style="color: #666; margin-bottom: 20px;">
                    é›†ã‚ãŸæ‰‹ãŒã‹ã‚Š: ${gameState.clues.length}å€‹
                </p>
                <button class="control-button" onclick="location.reload();">
                    ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤
                </button>
            `;
            
            modal.style.display = 'flex';
            
            // èŠ±ç«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            gameState.animations.extras = [];
            for (let i = 0; i < 5; i++) {
                gameState.animations.extras.push({
                    type: 'celebration',
                    x: 100 + i * 150,
                    y: canvas.height / 2
                });
            }
        }

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeModal() {
            document.getElementById('modal').style.display = 'none';
        }

        // åˆæœŸæç”»
        window.addEventListener('load', () => {
            // åˆæœŸç”»é¢ã«æ¢åµã‚’æç”»
            requestAnimationFrame(animate);
        });

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã«ä¸€æ™‚çš„ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            gameState.animations.extras.push({
                type: 'celebration',
                x: x,
                y: y,
                duration: 30
            });
            
            // 30ãƒ•ãƒ¬ãƒ¼ãƒ å¾Œã«å‰Šé™¤
            setTimeout(() => {
                gameState.animations.extras = gameState.animations.extras.filter(e => e.duration !== 30);
            }, 500);
        });
    </script>
</body>
</html>